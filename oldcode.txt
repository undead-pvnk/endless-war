    EwPoi(
        id_poi = "assaultflatsbeachstreeta",
        alias = ['paradiseslums', 'paradise'],
        str_name = "Paradise Slums",
        str_desc = "It's an adorable beachtown which has long ago slid into decay. The further you get from the coast, the more homelessness and vandalism run rampant. The only thing left to remind you that you're on vacation are the palm trees. This street connects back into Assault Flats Beach. This street is connected to Broadway, and Beachfront Properties. This street also exits into Assault Flats Beach Pier, The Assault Flats Beach Blimp Tower, and Nuclear Beach Edge.",
        channel = "paradise-slums",
        major_role = "assaultflatsbeach_major",
        minor_role = "assaultflatsbeachstreeta_minor",
        permissions = {'assaultflatsbeachstreeta': ['read', 'send', 'connect']},
        property_class = "s",
        is_street = True,
        father_district = "assaultflatsbeach",
        neighbors = {'assaultflatsbeach': 20, 'assaultflatsbeachstreetb': 20, 'newnewyonkersstreetb': 20, 'nuclearbeachedge': 20, 'assaultflatsbeachpier': 20, 'assaultflatsblimptower': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Assault_Flats_Beach#Paradise_Slums",
    ),
        EwPoi(
        id_poi = "oldnewyonkersstreetc",
        alias = ['luxurytownhouses', 'luxury'],
        str_name = "Luxury Townhouses",
        str_desc = "This row of ornately designed, spacious townhouses are home to some retired captains of industry. They've had their fun making metric fucktons of slime through worker exploitation and literal cattle slavery, they've come here to waste away with their families. This area is patrolled by the neighborhood watch, which keeps out the troublemakers. You've got nothing to worry about though, they're all in wheelchairs or using walkers. This street connects back into Old New Yonkers. This street is connected to Brawlden Private School District, Old Folks Home, and Shopping Center.",
        channel = "luxury-townhouses",
        major_role = "oldnewyonkers_major",
        minor_role = "oldnewyonkersstreetc_minor",
        permissions = {'oldnewyonkersstreetc': ['read', 'send', 'connect']},
        property_class = "a",
        is_street = True,
        father_district = "oldnewyonkers",
        neighbors = {'oldnewyonkers': 20, 'oldnewyonkersstreetb': 20, 'oldnewyonkersstreetd': 20, 'brawldenstreetc': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Old_New_Yonkers#Luxury_Townhouses",
    ),
        EwPoi(
        id_poi = "brawldenstreetd",
        alias = ['usedcardealership', 'usedcar', 'used'],
        str_name = "Used Car Dealership",
        str_desc = "This place is fucking huge. There's terrible, barely functioning used cars for as far as the eye can see. Salesmen know better than to annoy a gangster with their prattle, but they do still sneak up on you every once and try to weasel their way into a sale. Just blast one of their limbs off and they'll leave you along again. This street connects back into Brawlden. This street is connected to Abandoned Warehouse, Brawlden Private School District, and Reactor Ground Zero.",
        channel = "used-car-dealership",
        major_role = "brawlden_major",
        minor_role = "brawldenstreetd_minor",
        permissions = {'brawldenstreetd': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "brawlden",
        neighbors = {'brawlden': 20, 'brawldenstreetc': 20, 'brawldenstreeta': 20, 'littlechernobylstreetb': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Brawlden#Used_Car_Dealership",
    ),
        EwPoi(
        id_poi = "brawldenstreetc",
        alias = ['brawldenprivateschooldistrict', 'privateschooldistrict', 'privateschool', 'private'],
        str_name = "Brawlden Private School District",
        str_desc = "The buff dads in Brawlden don't always get the manliest sons. For those who got twinks, they get sent to Brawlden Prep School for the Physically Unfit to get jacked and follow in their father's footsteps. And as you can imagine, once the slime came, the school's already impossible standards of discipline grew into something psychopathic. The motto carved above the stone building's entrance used to read 'Anything that doesn't kill you makes you stronger.' Now, it's 'The Zenkai boost is real and we're going to kill you until you can bench 450.'  This street connects back into Brawlden. This street is connected to Brownstone Row, Used Car Dealership, and Luxury Townhouses.",
        channel = "brawlden-private-school-district",
        major_role = "brawlden_major",
        minor_role = "brawldenstreetc_minor",
        permissions = {'brawldenstreetc': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "brawlden",
        neighbors = {'brawlden': 20, 'brawldenstreetb': 20, 'brawldenstreetd': 20, 'oldnewyonkersstreetc': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Brawlden#Brawlden_Priavte_School_District",
    ),
        EwPoi(
        id_poi = "arsonbrookstreetc",
        alias = ['tillyhill', 'tilly'],
        str_name = "Tilly Hill",
        str_desc = "It's a steep road leading uphill to a big scenic area overlooking Cinder State Forest. Tricksters like to toss trash cans and other large garbage over the hill to hit cars driving up. This street connects back into Arsonbrook. This street is connected to Cinder State Forest, Crassus Square, and Ski Lodges.",
        channel = "tilly-hill",
        major_role = "arsonbrook_major",
        minor_role = "arsonbrookstreetc_minor",
        permissions = {'arsonbrookstreetc': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "arsonbrook",
        neighbors = {'arsonbrook': 20, 'arsonbrookstreetb': 20, 'arsonbrookstreetd': 20, 'maimridgestreetb': 20, 'northoutskirtsedge': 60},
        wikipage = "https://rfck.miraheze.org/wiki/Arsonbrook#Tilly_Hill",
    ),
    EwPoi(
        id_poi = "arsonbrookstreetd",
        alias = ['crassussquare', 'crassus'],
        str_name = "Crassus Square",
        str_desc = "This row of homes are victim to frequent acts of arson from fellow locals. No one knows why, exactly. The houses in question are usually quite flamboyantly luxurious, and so the attacks could be as a protest of gentrification or simply as revenge enacted on those who have by those who have not. Regardless, if you buy property here, expect to be rebuilding it every few years. This street connects back into Arsonbrook. This street is connected to Tilly Hill, Riverbank, and Abandoned Warehouse.",
        channel = "crassus-square",
        major_role = "arsonbrook_major",
        minor_role = "arsonbrookstreetd_minor",
        permissions = {'arsonbrookstreetd': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "arsonbrook",
        neighbors = {'arsonbrook': 20, 'arsonbrookstreetc': 20, 'arsonbrookstreete': 20, 'brawldenstreeta': 20, 'northoutskirtsedge': 60},
        wikipage = "https://rfck.miraheze.org/wiki/Arsonbrook#Crassus_Square",
    ),
        EwPoi(
        id_poi = "arsonbrookstreeta",
        alias = ['stillwatertown', 'stillwater'],
        str_name = "Stillwater town",
        str_desc = "This small community looks like it was plucked right out of the pacfic northwest, or one of the results of a Google Images search for 'Roslyn, Washington'. Nestled cozily on the southern half of the district, this is where most of Arsonbrook's economic activity occurs. This street connects back into Arsonbrook. This street is connected to Pollution Dumping Wharf, Cinder State Forest, and Riverbank. This street also exits into The Arsonbrook Farms, and The Arsonbrook Subway Station.",
        channel = "stillwater-town",
        major_role = "arsonbrook_major",
        minor_role = "arsonbrookstreeta_minor",
        permissions = {'arsonbrookstreeta': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "arsonbrook",
        neighbors = {'arsonbrook': 20, 'arsonbrookstreete': 20, 'arsonbrookstreetb': 20, 'smogsburgstreeta': 20, 'arsonbrookfarms': 20, 'arsonbrooksubwaystation': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Arsonbrook#Stillwater_Town",
    ),
        EwPoi(
        id_poi = "smogsburgstreetc",
        alias = ['companytownsquare', 'companytown', 'company'],
        str_name = "Company Town Square",
        str_desc = "This square is owned and maintained by a consortium of the leading companies in the city. It's a small park, surrounded by cheap takeout places and convenience stores. It was only created after a general strike demanding some form of recreational space in the district, to which the consortium reluctantly accepted. In the center of the square are monuments and statues dedicated to industry. Use of made-up company currency is encouraged in exchange here. This street connects back into Smogsburg. This street is connected to Cop Killtown, The West Quarter, and Sludge Refinery. This street also exits into The Smogsburg Subway Station",
        channel = "company-town-square",
        major_role = "smogsburg_major",
        minor_role = "smogsburgstreetc_minor",
        permissions = {'smogsburgstreetc': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "smogsburg",
        neighbors = {'smogsburg': 20, 'smogsburgstreetb': 20,  'copkilltown': 20, 'smogsburgsubwaystation': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Smogsburg#Company_Town_Square",
    ),
        EwPoi(
        id_poi = "smogsburgstreeta",
        alias = ['pollutiondumpingwharf', 'pollutiondumping', 'pollution'],
        str_name = "Pollution Dumping Wharf",
        str_desc = "The various refineries and chemical plants here use this industrial wharf as the perfect site to dump all of their waste into the River of Slime, resulting in heavy pollution. This is literally fine, and everyone loves it. This street connects back into Smogsburg. This street is connected to The West Quarter, Factory Row, and Stillwater town.",
        channel = "polution-dumping-wharf",
        major_role = "smogsburg_major",
        minor_role = "smogsburgstreeta_minor",
        permissions = {'smogsburgstreeta': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "smogsburg",
        neighbors = {'smogsburg': 20, 'smogsburgstreete': 20, 'smogsburgstreetb': 20, 'arsonbrookstreeta': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Smogsburg#Pollution_Dumping_Wharf",
    ),
    EwPoi(
        id_poi = "smogsburgstreetb",
        alias = ['thewestquarter', 'westquarter', 'quarter'],
        str_name = "The West Quarter",
        str_desc = "This bustling corner of Smogsburg is really the only commercial zone in the district. Spread out throughout the marketplace are densely packed food stands, apparel stores, and places selling conspicuously useless junk. None of the places are particularly big. In the center of this is the district's bazaar, which is where most of the traffic through this part of town is heading. This street connects back into Smogsburg. This street is connected to Gated Community, Pollution Dumping Wharf, and Company Town Square.",
        channel = "west-quarter",
        major_role = "smogsburg_major",
        minor_role = "smogsburgstreetb_minor",
        permissions = {'smogsburgstreetb': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "smogsburg",
        neighbors = {'smogsburg': 20, 'smogsburgstreeta': 20, 'smogsburgstreetc': 20, 'astatineheightsstreete': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Smogsburg#The_West_Quarter",
    ),
        EwPoi(
        id_poi = "astatineheightsstreete",
        alias = ['gatedcommunity', 'gated'],
        str_name = "Gated Community",
        str_desc = "This neighborhood is surrounded by two sets of twenty meter high and ten meter wide walls, with watchtowers and barracks routinely posted around the parameter. It's patrol all hours of the day, and solicitors are often piledrived by these guards well before they get anywhere close to breaching the walls. This street connects back into Astatine Heights. This street is connected to Astatine Trail, Barbette Boulevard, and The West Quarter.",
        channel = "gated-community",
        major_role = "astatineheights_major",
        minor_role = "astatineheightsstreete_minor",
        permissions = {'astatineheightsstreete': ['read', 'send', 'connect']},
        property_class = "a",
        is_street = True,
        father_district = "astatineheights",
        neighbors = {'astatineheights': 20, 'astatineheightsstreetd': 20, 'astatineheightsstreetf': 20, 'smogsburgstreetb': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Astatine_Heights#Gated_Community",
    ),
        EwPoi(
        id_poi = "astatineheightsstreetd",
        alias = ['astatinetrail', 'trail'],
        str_name = "Astatine Trail",
        str_desc = "A rugged asphalt bike path is all that separates this scenic nature walk from anywhere else in Cinder State Forest. You're just as likely to get mauled by bears or choke to death from the smoke of its iconic forest fires, but even so, the residents love this place for its 'natural beauty' or whatever they call it. It's spawned a sort of aged-hippie type hiking subculture that makes you sick. You can often watch them die though, so there's that. This street connects back into Astatine Heights. This street is connected to Mountain Condos, Gated Community, and Cinder State Forest.",
        channel = "astatine-trail",
        major_role = "astatineheights_major",
        minor_role = "astatineheightsstreetd_minor",
        permissions = {'astatineheightsstreetd': ['read', 'send', 'connect']},
        property_class = "a",
        is_street = True,
        father_district = "astatineheights",
        neighbors = {'astatineheights': 20, 'astatineheightsstreetc': 20, 'astatineheightsstreete': 20, 'arsonbrookstreetb': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Astatine_Heights#Astatine_Trail",
    ),
        EwPoi(
        id_poi = "astatineheightsstreeta",
        alias = ['eightyfifthstreet', 'eightyfifth', '85thstreet', '85th', '85'],
        str_name = "85th Street",
        str_desc = "This street is full of upscale bars and fancy restaurants. It's one of the few places to actually have a night out on the town in Astatine Heights, so you'll see a lot of upper class snobs in their fancy dresses celebrating some dumb shit that just makes you want to shoot them, like cinco de mayo or kwanzaa. This street connects back into Astatine Heights. This street is connected to Sludgeberry Street, Decaying Slums, and Barbette Boulevard. This street also exits into The Astatine Heights Subway Station",
        channel = "eighty-fifth-street",
        major_role = "astatineheights_major",
        minor_role = "astatineheightsstreeta_minor",
        permissions = {'astatineheightsstreeta': ['read', 'send', 'connect']},
        property_class = "a",
        is_street = True,
        father_district = "astatineheights",
        neighbors = {'astatineheights': 20, 'astatineheightsstreetf': 20, 'astatineheightsstreetb': 20, 'gatlingsdalestreete': 20, 'astatineheightssubwaystation': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Astatine_Heights#85th_Street",
    ),
    EwPoi(
        id_poi = "astatineheightsstreetb",
        alias = ['decayingslums', 'decaying'],
        str_name = "Decaying Slums",
        str_desc = "This embarrassing blemish on the district's squeaky clean reputation is tucked away from the rest of Astatine Heights. The poor that call this ghetto their home usually make their rent mining in Toxington, which isn't exactly a safe or rewarding line of work. What little expendable income they accrue is spent on frivolous bullshit to make themselves feel less poor. This street connects back into Astatine Heights. This street is connected to Geyser Springs, 85th Street, and Mountain Condos. This street also exits into Red Mobster Seafood, and The Astatine Heights Subway Station.",
        channel = "decaying-slums",
        major_role = "astatineheights_major",
        minor_role = "astatineheightsstreetb_minor",
        permissions = {'astatineheightsstreetb': ['read', 'send', 'connect']},
        property_class = "a",
        is_street = True,
        father_district = "astatineheights",
        neighbors = {'astatineheights': 20, 'astatineheightsstreeta': 20, 'astatineheightsstreetc': 20, 'toxingtonstreete': 20, 'redmobster': 20, 'astatineheightssubwaystation': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Astatine_Heights#Decaying_Slums",
    ),
    EwPoi(
        id_poi = "astatineheightsstreetc",
        alias = ['mountaincondos', 'condos'],
        str_name = "Mountain Condos",
        str_desc = "These condominiums are high up, in fact this neighborhood is so high up you can see most of Astatine Heights and surrounding districts from it. The places here are really swanky, and are mostly the bachelor pads of teenybopper robber barons shamelessly cosplaying Elon Musk. This street connects back into Astatine Heights. This street is connected to Decaying Slums, Astatine Trail, and The Summit.",
        channel = "mountain-condos",
        major_role = "astatineheights_major",
        minor_role = "astatineheightsstreetc_minor",
        permissions = {'astatineheightsstreetc': ['read', 'send', 'connect']},
        property_class = "a",
        is_street = True,
        father_district = "astatineheights",
        neighbors = {'astatineheights': 20, 'astatineheightsstreetb': 20, 'astatineheightsstreetd': 20, 'maimridgestreeta': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Astatine_Heights#Mountain_Condos",
    ),
        EwPoi(
        id_poi = "gatlingsdalestreetc",
        alias = ['', ''],
        str_name = "University Square",
        str_desc = "This is a commercial center for students of nearby N.L.A.C.U., and the greater Gatlingsdale population. Convenience stores, local restaurants, and designer clothing stores targeted towards rich hipsters all appear right next to one another. It's pretty cool, if you like getting a good meal and window shopping for stuff you'd never be able to afford to buy. This street connects back into Gatlingsdale. This street is connected to Wholesale Warehouse, N.L.A.C.U. Campus, and N.L.A.C.U. Institute of Slimeology.",
        channel = "university-square",
        major_role = "gatlingsdale_major",
        minor_role = "gatlingsdalestreetc_minor",
        permissions = {'gatlingsdalestreetc': ['read', 'send', 'connect']},
        property_class = "a",
        is_street = True,
        father_district = "gatlingsdale",
        neighbors = {'gatlingsdale': 20, 'gatlingsdalestreetb': 20, 'gatlingsdalestreetd': 20, 'poloniumhillstreeta': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Gatlingsdale#University_Square",
    ),
        EwPoi(
        id_poi = "gatlingsdalestreetb",
        alias = ['nlacucampus', 'campus'],
        str_name = "N.L.A.C.U. Campus",
        str_desc = "This sprawling campus contains dormitories, mess halls, libraries, classrooms,  auditoriums, department buildings, and several open spaces. It's fucking huge, it takes up just over a quarter of the entire district. It's almost like a district unto itself, with its own internal government and security guard. This street connects back into Gatlingsdale. This street is connected to Tookewlforskewl Skatepark, The Garage, and University Square. This street also exits into New Los Angeles City University",
        channel = "nlacu-campus",
        major_role = "gatlingsdale_major",
        minor_role = "gatlingsdalestreetb_minor",
        permissions = {'gatlingsdalestreetb': ['read', 'send', 'connect']},
        property_class = "a",
        is_street = True,
        father_district = "gatlingsdale",
        neighbors = {'gatlingsdale': 20, 'gatlingsdalestreeta': 20, 'gatlingsdalestreetc': 20, 'vandalparkstreetc': 20, 'newlosangelescityuniversity': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Gatlingsdale#NLACU_Campus",
    ),
        EwPoi(
        id_poi = "toxingtonstreete",
        alias = ['geysersprings', 'geyser'],
        str_name = "Geyser Springs",
        str_desc = "It's hard to miss the plumes of molten, toxic sludge spewing into the air every fifteen seconds, but still, watch your step. If you fall into one of these things, you're toast. If you're not instantly cooked through, then you'll be eaten alive by some of the terrifying creatures that have evolved to withstand the inhospitable conditions. A few morons have built piers over the calmer springs in an attempt to wrangle some of those aforementioned beasts, and it usually goes as well as you would expect. This street connects back into Toxington. This street is connected to Gravel Mounds, Carcinogenic Quarry, and Decaying Slums. This street also exits into Toxington Pier, and The Toxington Subway Station.",
        channel = "geyser-springs",
        major_role = "toxington_major",
        minor_role = "toxingtonstreete_minor",
        permissions = {'toxingtonstreete': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "toxington",
        neighbors = {'toxington': 20, 'toxingtonstreetd': 20, 'toxingtonstreeta': 20, 'astatineheightsstreetb': 20, 'toxingtonpier': 20, 'toxingtonsubwaystation': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Toxington#Geyser_Springs",
    ),
        EwPoi(
        id_poi = "toxingtonstreetb",
        alias = ['cyanideswamp', 'cyanide'],
        str_name = "Cyanide Swamp",
        str_desc = "This hot, wet marsh used to be the coolest, newest spot to mine slime in Toxington. The area was particularly well known for its abundance of poudrins. However, after most of the miners began turning up empty handed after mining for weeks on end, there was a shift from trying to extract as many poudrins as possible to trying to get as much slime as possible from the poudrins you got. See, crushing poudrins ain't a science, it's an art. When just crushing it with your bare hands, inevitably some of the poudrin doesn't get converted into slime and is therefore wasted. Some clever miners found out that you could combine cyanide with a water mixture and when you submerged a poudrin into it, you'd be able to strain it all and wind up with a particularly well concentrated distillation of pure slime-- perfect for crushing. Well, this was so popular that the leftover sludge mixture began to pile up and up until its containment unit broke and flooded all the shafts in the region with its goopy innards. All of the bogs you see around you were once profitable mineshafts. This street connects back into Toxington. This street is connected to Curie Highschool, Gravel Mounds, and Quarantined Zones.",
        channel = "cyanide-swamp",
        major_role = "toxington_major",
        minor_role = "toxingtonstreetb_minor",
        permissions = {'toxingtonstreetb': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "toxington",
        neighbors = {'toxington': 20, 'toxingtonstreeta': 20, 'toxingtonstreetc': 20, 'poloniumhillstreetb': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Toxington#Cyanide_Swamp",
    ),
    EwPoi(
        id_poi = "toxingtonstreetc",
        alias = ['quarantinedzones', 'quarantined'],
        str_name = "Quarantined Zones",
        str_desc = "Here's some food for thought. What would a residential zone look like in a place filled entirely with toxic gases? Well good news, you're standing in one! Being closest to Toxington's deadly gas deposits, the homes here have long since been abandoned, still full of the rotting food and corroded appliances their original owners had. You may think to yourself, staring into the dark green hazy sky and breathing in more cyanide, that you could live in one of these places. Well, you could, if you had more than 6 seconds to live. This street connects back into Toxington. This street is connected to The Church of the Holy Slimefoot, Cyanide Swamp, and Carcinogenic Quarry.",
        channel = "quarantined-zones",
        major_role = "toxington_major",
        minor_role = "toxingtonstreetc_minor",
        permissions = {'toxingtonstreetc': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "toxington",
        neighbors = {'toxington': 20, 'toxingtonstreetb': 20, 'toxingtonstreetd': 20, 'charcoalparkstreeta': 20, 'northwestoutskirtsedge': 60},
        wikipage = "https://rfck.miraheze.org/wiki/Toxington#Quarantined_Zones",
    ),
    EwPoi(
        id_poi = "toxingtonstreetd",
        alias = ['carcinogenicquarry', 'carcinogenic', 'carcinogen'],
        str_name = "Carcinogenic Quarry",
        str_desc = "This old mining complex isn't used that often anymore, despite large deposits of slime still lurking in the shafts below. After an initial burst of attention in the area, it was quickly discovered that the entire area is perhaps the single most irradiated area in the city, besides of course the site of the old reactor in Little Chernobyl. That isn't to say a little fear of death stopped anyone from mining slime, but the sheer concentration of radiation here made it hard to even get to the slime veins in the first place before croaking. Plus, with the gravel mounds just a hop, skip, and a jump away, who needs to waste time making razor thin profit margins here when they can throw their lives away in shafts where they'll actually make some real slime. This street connects back into Toxington. This street is connected to Quarantined Zones, Geyser Springs, and Colloid Springs. This street also exits into Toxington Pier",
        channel = "carcinogenic-quarry",
        major_role = "toxington_major",
        minor_role = "toxingtonstreetd_minor",
        permissions = {'toxingtonstreetd': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "toxington",
        neighbors = {'toxington': 20, 'toxingtonstreetc': 20, 'toxingtonstreete': 20, 'maimridgestreetc': 20, 'northwestoutskirtsedge': 60, 'toxingtonpier': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Toxington#Carcinogenic_Quarry",
    ),    EwPoi(
        id_poi = "charcoalparkstreetb",
        alias = ['veteranscenter', 'veterans', 'veteran'],
        str_name = "Veterans Center",
        str_desc = "The grass in this worn-down, red-brick veteran center has been completely dried out and trampled over. That makes sense, the residents here have used it as a base for their local militia for awhile now. Slimecorp managed to protect most districts from secreature invasions, but like usual, Charcoal Park was completely forgotten. That's why they now command their bravest, most senile senior citizens to do the protecting instead. This street connects back into Charcoal Park. This street is connected to Geller Point, and The Church of the Holy Slimefoot.",
        channel = "veterans-center",
        major_role = "charcoalpark_major",
        minor_role = "charcoalparkstreetb_minor",
        permissions = {'charcoalparkstreetb': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "charcoalpark",
        neighbors = {'charcoalpark': 20, 'charcoalparkstreeta': 20,  'northwestoutskirtsedge': 60},
        wikipage = "https://rfck.miraheze.org/wiki/Charcoal_Park#Veterans_Center",
    ),
    EwPoi(
        id_poi = "toxingtonstreeta",
        alias = ['gravelmounds', 'gravel', 'cp_gravelpit'],
        str_name = "Gravel Mounds",
        str_desc = "It may not look like much, but for miles below the ground here there are huge slime reserves, just begging to be mined. And so, people have dug extensive underground networks of mineshafts to haul as much slime out as possible. There's only one problem: This is Toxington. The underground of this district is filled with toxic gas that's lethal given prolonged exposure. Of course, that hasn't stopped slime-crazed lunatics from mining as much as they can. The mineshaft network is extensives, but all of the lines are narrow, so you're sure to step over a few cadavers on your way down to the exposed veins. Don't feel too bad for them, chances are they've just been spit out of ENDLESS WAR and are on their way back right now. This street connects back into Toxington. This street is connected to Cyanide Swamp, Geyser Springs, and N.L.A.C.U. Institute of Slimeology. This street also exits into The Toxington Mines, and The Toxington Subway Station.",
        channel = "gravel-mounds",
        major_role = "toxington_major",
        minor_role = "toxingtonstreeta_minor",
        permissions = {'toxingtonstreeta': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "toxington",
        neighbors = {'toxington': 20, 'toxingtonstreete': 20, 'toxingtonstreetb': 20, 'gatlingsdalestreetd': 20, 'toxingtonmines': 20, 'toxingtonsubwaystation': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Toxington#Gravel_Mounds",
    ),    EwPoi(
        id_poi = "poloniumhillstreetb",
        alias = ['curiehighschool', 'curie'],
        str_name = "Curie Highschool",
        str_desc = "You're standing in the dried-out parking lot of a limp-wristed, bog standard high school. Curie High really tries its best to seem habitable, but that actually pretty low standard leaves the students here tired, disenfranchised, and ready to waterslide right down the school-to-prison pipeline. How about we whip out our spray cans and rifles and show these up and comers how it's done? This street connects back into Polonium Hill. This street is connected to Wholesale Warehouse, Geller Point, and Cyanide Swamp.",
        channel = "curie-highschool",
        major_role = "poloniumhill_major",
        minor_role = "poloniumhillstreetb_minor",
        permissions = {'poloniumhillstreetb': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "poloniumhill",
        neighbors = {'poloniumhill': 20, 'poloniumhillstreeta': 20,  'toxingtonstreetb': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Polonium_Hill#Curie_Highschool",
    ),
    EwPoi(
        id_poi = "poloniumhillstreetd",
        alias = ['sawdustlumberyard', 'sawdust'],
        str_name = "Sawdust Lumberyard",
        str_desc = "This isn't a particularly big forest, but it's big enough to have attracted young, upstart entrenupers looking to make some money destroying the environment. And so, this humble lumberyard was founded. This is where most of the log cabins being built in Maimridge, and some of the gaudy lookalikes in this district, get their wood. Extra flammable planks are sent to Arsonbrook in large droves throughout the year, but they don't know they're extra flammable. The privatterring vessels being built in the Vagrant's Corner shipyard also make use of materials from here. It's a pretty big deal, alright? This street connects back into Polonium Hill. This street is connected to Goosh Creek, Geller Point, and Sort Of Mansions.",
        channel = "sawdust-lumberyard",
        major_role = "poloniumhill_major",
        minor_role = "poloniumhillstreetd_minor",
        permissions = {'poloniumhillstreetd': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "poloniumhill",
        neighbors = {'poloniumhill': 20,  'westoutskirtsedge': 60},
        wikipage = "https://rfck.miraheze.org/wiki/Polonium_Hill#Sawdust_Lumberyard",
    ),
        EwPoi(
        id_poi = "poloniumhillstreeta",
        alias = ['wholesalewarehouse', 'wholesale'],
        str_name = "Wholesale Warehouse",
        str_desc = "This huge warehouse is packed to the brim with wide varieties of products, including groceries, liquor, pharmaceuticals, appliances, furniture, and more, all sold in bulk and laid out in a no-frills kinda way. It's so fucking big, you don't even know. It's basically mandatory to have a subscription membership to this place if you're a Polonium Hill local, even though it's pretty easy to sneak in. You guess the sort of people that live in Polonium Hill would instantly die upon being caught doing anything against the rules, ever, so it makes sense. Moms and their screaming, snot-nosed children dash around you with shopping carts full of extremely unhealthy yet delicious breakfast cereals and red meats. This place is sort of like hell. This street connects back into Polonium Hill. This street is connected to Curie Highschool, Sort Of Mansions, and University Square.",
        channel = "wholesale-warehouse",
        major_role = "poloniumhill_major",
        minor_role = "poloniumhillstreeta_minor",
        permissions = {'poloniumhillstreeta': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "poloniumhill",
        neighbors = {},
        wikipage = "https://rfck.miraheze.org/wiki/Polonium_Hill#Wholesale_Warehouse",
    ),
        EwPoi(
        id_poi = "vandalparkstreetd",
        alias = ['theplayground', 'playground', 'play'],
        str_name = "The Playground",
        str_desc = "It's a totally gay playground made for pissy baby fucker fappers, for babies who poop their pants. Just the sight of the primary colored jungle gym makes you visceral upset, even if you do want to hang from the bars upside down pretty bad. And, maybe while you're at it you can swing on the swings for a little bit. Actually, no, being a kindergartener is pretty based, you change your mind. Not to be confused for #playground, obviously. This street connects back into Vandal Park. This street is connected to Ashtray Park, Tookewlforskewl Skatepark, and Sort Of Mansions.",
        channel = "the-playground",
        major_role = "vandalpark_major",
        minor_role = "vandalparkstreetd_minor",
        permissions = {'vandalparkstreetd': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "vandalpark",
        neighbors = {'vandalpark': 20, 'vandalparkstreetc': 20, 'vandalparkstreeta': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Vandal_Park#The_Playground",
    ),
       EwPoi(
        id_poi = "vandalparkstreeta",
        alias = ['ashtraypark', 'ashtray'],
        str_name = "Ashtray Park",
        str_desc = "This old baseball stadium used to be where every upstanding gentlemen of leisure spent their afternoons, but ever since the Battle Arena opened it's slowly fallen out of favor. Sometimes locals still play games here, but most of the time it's just a place for heroin addicts to sleep or staged exhibitoinist porn to be shot. This street connects back into Vandal Park. This street is connected to Scanty Heights, The Fens, and The Playground. This street also exits into The Vandal Park Subway Station",
        channel = "ashtray-park",
        major_role = "vandalpark_major",
        minor_role = "vandalparkstreeta_minor",
        permissions = {'vandalparkstreeta': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "vandalpark",
        neighbors = {'vandalpark': 20, 'vandalparkstreetd': 20, 'vandalparkstreetb': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Vandal_Park#Ashtray_Park",
    ),
    EwPoi(
        id_poi = "vandalparkstreetb",
        alias = ['thefens', 'fens'],
        str_name = "The Fens",
        str_desc = "This wide, open marshland is the perfect place to experience the feeling of being alive with some straight up neurotypical activities like jogging, casual field sports, and cloud watching. Of course, if you're not a fucking pussy, you'll be gatting motherfuckers left and right as you rape the compettion in fifteen different simultaneously occurring collision sports like a true warrior. This street connects back into Vandal Park. This street is connected to Dog Parks, Ashtray Park, and Tookewlforskewl Skatepark.",
        channel = "the-fens",
        major_role = "vandalpark_major",
        minor_role = "vandalparkstreetb_minor",
        permissions = {'vandalparkstreetb': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "vandalpark",
        neighbors = {'vandalpark': 20, 'vandalparkstreeta': 20, 'vandalparkstreetc': 20, 'glocksburystreetb': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Vandal_Park#The_Fens",
    ),
        EwPoi(
        id_poi = "jaywalkerplainstreetc",
        alias = ['theemeraldnoose', 'theemerald', 'emeralnoose', 'emerald'],
        str_name = "The Emerald Noose",
        str_desc = "This collection of green spaces comprise the majority of the land in Jaywalker Plain, hence the 'plain' part. Originally, Jaywalker Plain was intended to be an upper class district, and so these spaces would provide some leisure space for the oligarchs of the city to unwind, away from the hustle and bustle of slimegain. Needless to say, that, uh, didn't work out. These spaces are beautiful, but the real reason to come here is to point and laugh at all the crazy freaks, drug addicts, and homeless people picking fights with one another and passing out from overdoses at 2 PM in the afternoon next to austere marble busts and exotic trees. This street connects back into Jaywalker Plain. This street is connected to Black Alleyways, Qoute Unqoute Art Galleries, and Scaffold Forest. This street also exits into Jaywalker Plain Pier",
        channel = "the-emerald-noose",
        major_role = "jaywalkerplain_major",
        minor_role = "jaywalkerplainstreetc_minor",
        permissions = {'jaywalkerplainstreetc': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "jaywalkerplain",
        neighbors = {'jaywalkerplain': 20, 'jaywalkerplainstreetb': 20, 'jaywalkerplainstreetd': 20, 'dreadfordstreeta': 20, 'westoutskirtsedge': 60, 'jaywalkerplainpier': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Jaywalker_Plain#The_Emerald_Noose",
    ),
    EwPoi(
        id_poi = "jaywalkerplainstreetd",
        alias = ['qouteunqouteartgalleries', 'qouteunqouteart', 'qouteunqoute', 'qoute'],
        str_name = "Qoute Unqoute Art Galleries",
        str_desc = "This open outdoor market is the perfect place for the creative locals of Jaywalker Plain to show off their aesthetic genius and display their culturally enrichment gesamtkunstwerks for the world to see. Of course, this is Jaywalker Plain we're talking bout, so you're less likely to see portraits and still lifes as you are to see impressionistic depictions of drug-induced hallucinations and modern art commentating on how badly the artist wants to fuck dogs. This street connects back into Jaywalker Plain. This street is connected to Highway 89-A, The Emerald Noose, and Tent City. This street also exits into Jaywalker Plain Pier",
        channel = "qoute-unqoute-art-galleries",
        major_role = "jaywalkerplain_major",
        minor_role = "jaywalkerplainstreetd_minor",
        permissions = {'jaywalkerplainstreetd': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "jaywalkerplain",
        neighbors = {'jaywalkerplain': 20, 'jaywalkerplainstreetc': 20, 'jaywalkerplainstreete': 20, 'westoutskirtsedge': 60, 'jaywalkerplainpier': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Jaywalker_Plain#Qoute_Unqoute_Art_Galleries",
    ),
    EwPoi(
        id_poi = "jaywalkerplainstreete",
        alias = ['tentycity', 'tent'],
        str_name = "Tent City",
        str_desc = "This street used to be a congested road, but now the only traffic on it are hobos really putting the 'home' in 'homeless'. Tents and cardboard boxes are set up up and down this street, providing totally sufficient protection against the elements for their swathes of downtrodden inhabitants. Generations of people impoverished from birth have grown up here, never knowing anything but the tents. Drug abuse and violent crimes are rampant. Many have lost their minds and ramble on about insane conspiracy theorists and incoherent beliefs. It would be funny if it weren't so sad. Actually, that last part is still funny. Who ever heard of a 'round earth'? This street connects back into Jaywalker Plain. This street is connected to Mugshot Road, Outside the Planned Parenthood, and Qoute Unqoute Art Galleries.",
        channel = "tent-city",
        major_role = "jaywalkerplain_major",
        minor_role = "jaywalkerplainstreete_minor",
        permissions = {'jaywalkerplainstreete': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "jaywalkerplain",
        neighbors = {'jaywalkerplain': 20, 'jaywalkerplainstreetd': 20, 'jaywalkerplainstreeta': 20, 'glocksburystreetd': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Jaywalker_Plain#Tent_City",
    ),
    EwPoi(
        id_poi = "dreadfordstreeta",
        alias = ['scaffoldforest', 'scaffold'],
        str_name = "Scaffold Forest",
        str_desc = "This spooky forest has been the site of countless lynchings in the district's past (and present). Nooses hang from nearly every tree, and a thick fog makes those shadows in the distance all the more unnerving. This street connects back into Dreadford. This street is connected to The Emerald Noose, and Hang-'Em Square.",
        channel = "scaffold-forest",
        major_role = "dreadford_major",
        minor_role = "dreadfordstreeta_minor",
        permissions = {'dreadfordstreeta': ['read', 'send', 'connect']},
        property_class = "s",
        is_street = True,
        father_district = "dreadford",
        neighbors = {'dreadford': 20, 'dreadfordstreetb': 20, 'jaywalkerplainstreetc': 20, 'southwestoutskirtsedge': 60},
        wikipage = "https://rfck.miraheze.org/wiki/Dreadford#Scaffold_Forest",
    ),
        EwPoi(
        id_poi = "glocksburystreetb",
        alias = ['dogparks', 'dog'],
        str_name = "Dog Parks",
        str_desc = "This is one of the several dog parks around Glocksbury. Since the locals here are in (barely) safer conditions, they feel comfortable walking their dogs here. The park has tried its best to adapt to Slimeoids, too, but at the moment the best solution is to segregate the pets and Slimeoids in two separate enclosures. This is mostly to stop the dumbfuck boomers from crying a river when their dog gets excommunicated to a lower rung on the food chain via devouring by a vastly cooler and way more slime-based Slimeoid. This street connects back into Glocksbury. This street is connected to Police Station, Snitch Street, and The Fens.",
        channel = "dog-parks",
        major_role = "glocksbury_major",
        minor_role = "glocksburystreetb_minor",
        permissions = {'glocksburystreetb': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "glocksbury",
        neighbors = {'glocksbury': 20, 'glocksburystreeta': 20, 'glocksburystreetc': 20, 'vandalparkstreetb': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Glocksbury#Dog_Parks",
    ),
    EwPoi(
        id_poi = "glocksburystreetc",
        alias = ['snitchstreet', 'snitch'],
        str_name = "Snitch Street",
        str_desc = "The police are so desperate for itelligence about gang violence and territory control that they've brought this entire neighborhood off. You'll be minding your own business and in the span of half an hour you'll have talked to fourteen different people who all swear they aren't cops but are just dying to know your gang's organizational structure, troop movements, and what your personal top five biggest fears are. This street connects back into Glocksbury. This street is connected to Dog Parks, Mugshot Road, and Oilscum Avenue. This street also exits into The Glocksbury Subway Station",
        channel = "snitch-street",
        major_role = "glocksbury_major",
        minor_role = "glocksburystreetc_minor",
        permissions = {'glocksburystreetc': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "glocksbury",
        neighbors = {'glocksbury': 20, 'glocksburystreetb': 20, 'glocksburystreetd': 20, 'glocksburysubwaystation': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Glocksbury#Snitch_Street",
    ),
    EwPoi(
        id_poi = "glocksburystreetd",
        alias = ['mugshotroad', 'mugshot'],
        str_name = "Mugshot Road",
        str_desc = "This is an affordable housing community. Most of the inhabitants here are some Jaywalker Plain, who have tried to kick whatever addictions were holding them back in their old life and start again here. Because of the vulnerable nature of the residents here, the police have carte balance to do whatever the fuck they want with them, and they do! Random entries into people's homes without warrants, excessive uses of force for literally no reason, frisking before they even have the decency to stop-and- you first, asking you to hold something for them before placing incriminating evidence into your hands without waiting for your response and then pulling out their gun and murdering you, piledrivings, and more. Basically, real life. This street connects back into Glocksbury. This street is connected to Snitch Street, Cul-de-sac, and Tent City.",
        channel = "mugshot-road",
        major_role = "glocksbury_major",
        minor_role = "glocksburystreetd_minor",
        permissions = {'glocksburystreetd': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "glocksbury",
        neighbors = {'glocksbury': 20, 'glocksburystreetc': 20, 'glocksburystreete': 20, 'jaywalkerplainstreete': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Glocksbury#Mugshot_Road",
    ),
    EwPoi(
        id_poi = "glocksburystreete",
        alias = ['culdesac'],
        str_name = "Cul-de-sac",
        str_desc = "It's just a totally ordinary cul-de-sac with no special attributes or defining features. Presumably the residents here think that because the police station's right down the road that they can act all normal and shit, and that they can avoid the worst of the gang violence. They've got another thing coming. This street connects back into Glocksbury. This street is connected to Slob Plaza, Police Station, and Mugshot Road.",
        channel = "cul-de-sac",
        major_role = "glocksbury_major",
        minor_role = "glocksburystreete_minor",
        permissions = {'glocksburystreete': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "glocksbury",
        neighbors = {},
        wikipage = "https://rfck.miraheze.org/wiki/Glocksbury#Cul-de-sac",
    ),
        EwPoi(
        id_poi = "northsleezeboroughstreetb",
        alias = ['wwwring', 'www', 'ring'],
        str_name = "WWW Ring",
        str_desc = "It's a big amphitheater with a Fighting Ring for a stage: The place where the Wowie Wowza Wrestling Circuit takes place. Founded on the very land the great West-East Gaijin War happened, it was once a great promotion for all the up and coming superstars of the city, like Stoned Cold Beer Monger and Musk Logan, but it became reduced to a bunch of retards in spandex slapping each other while completely drunk. It's not all bad for the dwindling crowds, as once in a green moon they get to see an extreme fit of rage or an aneurysm happen mid-show, which is extremely fucking funny. This street connects back into North Sleezeborough. This street is connected to Little Italy, Drive-By Drive-Thrus, and Carbohydrate Containment Boulevard.",
        channel = "www-ring",
        major_role = "northsleezeborough_major",
        minor_role = "northsleezeboroughstreetb_minor",
        permissions = {'northsleezeboroughstreetb': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "northsleezeborough",
        neighbors = {'northsleezeborough': 20, 'northsleezeboroughstreeta': 20, 'northsleezeboroughstreetc': 20, 'southsleezeboroughstreetb': 20},
        wikipage = "https://rfck.miraheze.org/wiki/North_Sleezeborough#WWW_Ring",
    ),
    EwPoi(
        id_poi = "northsleezeboroughstreetc",
        alias = ['carbohydratecontainmentboulevard', 'carbohydratecontainment', 'carbohydrate'],
        str_name = "Carbohydrate Containment Boulevard",
        str_desc = "As far as you can see the street is lined with pizza places of all shapes and sizes. Even more dwarfing than the amount of pie shops is the sweet smell of some piping hot slices that are ready to be devoured. Even just walking down this street is enough to punch you out of ketosis. The never-ending supply of grease and dough being funneled into the local's mouths keeps them fat and complacent. This street connects back into North Sleezeborough. This street is connected to WWW Ring, Pond Scum Road, and Manteca Street.",
        channel = "carbohydrate-containment-boulevard",
        major_role = "northsleezeborough_major",
        minor_role = "northsleezeboroughstreetc_minor",
        permissions = {'northsleezeboroughstreetc': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "northsleezeborough",
        neighbors = {'northsleezeborough': 20, 'northsleezeboroughstreetb': 20, 'northsleezeboroughstreetd': 20},
        wikipage = "https://rfck.miraheze.org/wiki/North_Sleezeborough#Carbohydrate_Containment_Boulevard",
    ),
    EwPoi(
        id_poi = "northsleezeboroughstreetd",
        alias = ['pondscumroad', 'pondscum'],
        str_name = "Pond Scum Road",
        str_desc = "The street takes you next to a pond which looks as if it has seen better days. The surrounding grass is littered with trash long forgotten. The water seems to be much the same filled with half eaten pieces of bread, algae, and some other substances you can't quite identify. It looks like this place is often deserted even from the ducks. This street connects back into North Sleezeborough. This street is connected to Carbohydrate Containment Boulevard, Slob Plaza, and Outside the Planned Parenthood.",
        channel = "pond-scum-road",
        major_role = "northsleezeborough_major",
        minor_role = "northsleezeboroughstreetd_minor",
        permissions = {'northsleezeboroughstreetd': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "northsleezeborough",
        neighbors = {'northsleezeborough': 20, 'northsleezeboroughstreetc': 20, 'northsleezeboroughstreete': 20, 'jaywalkerplainstreeta': 20},
        wikipage = "https://rfck.miraheze.org/wiki/North_Sleezeborough#Pond_Scum_Road",
    ),
    EwPoi(
        id_poi = "northsleezeboroughstreete",
        alias = ['slobplaza', 'slob'],
        str_name = "Slob Plaza",
        str_desc = "It's the most bland square of land to ever be called a plaza, adorned by a couple of short trees, four pairs of benches each looking towards a different cardinal point, and a small, ugly dry fountain in the middle. Multiple magazines and renowned papers have called this spot number 1 in many \"The best places to nap or fall dead\" rankings, having mediocre ratings across the board since its inception. Here you can always find lazy citizens laying around, wishing their sorry lives could be magically solved' or, even better, that someone puts a bullet between those sleepy eyes. This street connects back into North Sleezeborough. This street is connected to Drive-By Drive-Thrus, Pond Scum Road, and Cul-de-sac.",
        channel = "slob-plaza",
        major_role = "northsleezeborough_major",
        minor_role = "northsleezeboroughstreete_minor",
        permissions = {'northsleezeboroughstreete': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "northsleezeborough",
        neighbors = {'northsleezeborough': 20, 'northsleezeboroughstreetd': 20, 'northsleezeboroughstreeta': 20, 'glocksburystreete': 20},
        wikipage = "https://rfck.miraheze.org/wiki/North_Sleezeborough#Slob_Plaza",
    ),
        EwPoi(
        id_poi = "oozegardensstreetd",
        alias = ['nlacakanmzoo', 'zoo'],
        str_name = "NLACakaNM Zoo",
        str_desc = "This  menagerie is home to dozens of rare species of beasts, both organic and slime-based, displayed in mock-ups of their natural habitat for maximum theming bonuses. Of course, some of the crazy shit that gets displayed here, especially the stuff from the outskirts, are all horrifying monstrosities that don't really have natural habitats or even really any proper rules on how to care for them. As such, the zoo's pretty nasty and brutish towards the animals, as they are sometimes held in inadequate conditions and kept in line with force. Whatever, though. Not your problem. Haha, look at those orangutans! They're so silly. This street connects back into Ooze Gardens. This street is connected to Dynamite Lane, Festival Grounds, and Museum Row. This street also exits into The Ooze Gardens Farms",
        channel = "nlacakanm-zoo",
        major_role = "oozegardens_major",
        minor_role = "oozegardensstreetd_minor",
        permissions = {'oozegardensstreetd': ['read', 'send', 'connect']},
        property_class = "a",
        is_street = True,
        father_district = "oozegardens",
        neighbors = {'oozegardens': 20, 'oozegardensstreetc': 20, 'oozegardensstreeta': 20, 'cratersvillestreetc': 20, 'southoutskirtsedge': 60, 'oozegardensfarms': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Ooze_Gardens#NLACakaNM_Zoo",
    ),
    EwPoi(
        id_poi = "southsleezeboroughstreeta",
        alias = ['chinatown', 'china', 'triad'],
        str_name = "Chinatown",
        str_desc = "Here, pagodas and dragon gates take up every square inch of land that asian restaurants and law firms don't. From the streets it's hard to make out the sky from the tacky lanterns and web of unintelligible business signs. For as far as the eye can see, there are embarrassingly inauthentic approximations of oriental architectural styles. But, you knew all that. So, here's something you may not have known: This whole corner of the district is run by the Triad. Yeah, all of those law firms? Have you ever been inside of one? Of course you haven't, no one has. They're just money laundering fronts and sometimes meeting spots for members to plan out their campaigns against whoever's been tardy with their tribute and who to extort from next. Of course, they provide a level of vigilante justice to the neighborhood too, punishing random acts of lawlessness in favor of their totally reasonable brand of lawlessness. These gangsters are a part of a long, complex history in South Sleezeborough between local weeaboos, immigrant westaboos, and their struggle for supremacy. This thorny issue has even threatened the integrity of the Triad itself, as some members wish to cling unto their traditional way of life and show solidarity with the asianophile weeaboos, while others have grown accustomed to their new cultures and support the westaboos. This question remains unsettled to this day. This street connects back into South Sleezeborough. This street is connected to Little Italy, Cartel Turf, and Lake Macguffin. This street also exits into The South Sleezeborough Subway Station",
        channel = "chinatown",
        major_role = "southsleezeborough_major",
        minor_role = "southsleezeboroughstreeta_minor",
        permissions = {'southsleezeboroughstreeta': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "southsleezeborough",
        neighbors = {'southsleezeborough': 20, 'southsleezeboroughstreetd': 20, 'southsleezeboroughstreetb': 20, 'southwestoutskirtsedge': 60, 'southsleezesubwaystation': 20},
        wikipage = "https://rfck.miraheze.org/wiki/South_Sleezeborough#Chinatown",
    ),
    EwPoi(
        id_poi = "southsleezeboroughstreetb",
        alias = ['littleitaly', 'italy', 'mafia'],
        str_name = "Little Italy",
        str_desc = "Whoa, hold the phone. Cool your jets. This may look like a normal neighborhood with densely packed red brick apartments and an anti-human grid plan, but it ain't. Cut it out with that whole free spirit punk attitude thing you've got going on and back the fuck up and start respecting the shit outta the people who grease the wheels around here. Don't you know that this place is run by the mob? Like, the mafia? Like, the famous Italian-American criminal organization with branches in several large metropolitan areas? Yes, that mafia! And you can bet your bottom dollar they're up to all their old tricks. Their whole byzantine family structure and 'battling for supremacy with rival clans' aesthetic got ported over full-sale. There's like a billion families here all battling over where each other can sell their illegal slime-based liquor that are totally legal but everyone wants to believe they aren't for old times' sake, who they're allowed to offer their 'protection' to, and what politicians they have the privilege of whacking. Lots of pizza places 'round here. This street connects back into South Sleezeborough. This street is connected to Chinatown, Little Tokyo, and WWW Ring. This street also exits into The Dojo",
        channel = "little-italy",
        major_role = "southsleezeborough_major",
        minor_role = "southsleezeboroughstreetb_minor",
        permissions = {'southsleezeboroughstreetb': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "southsleezeborough",
        neighbors = {'southsleezeborough': 20, 'southsleezeboroughstreeta': 20, 'southsleezeboroughstreetc': 20, 'northsleezeboroughstreetb': 20, 'thedojo': 20},
        wikipage = "https://rfck.miraheze.org/wiki/South_Sleezeborough#Little_Italy",
    ),
    EwPoi(
        id_poi = "southsleezeboroughstreetc",
        alias = ['littletokyo', 'littletokyo'],
        str_name = "Little Tokyo",
        str_desc = "Ohayo gozaimasu, motherfucker. Here in South Sleezeborough's Little Tokyo, which is just an outdoor shopping center with six parking spaces and even fewer stores located on the corner of a busy intersection, is a branch of the infamous Yazuka. These chivalrous knights of bushido hail from glorious Nippon, and seek to literally prevent culture death. Like, that's genuinely their whole deal. No joke. They're fucking ripped, wear suits and ties that are totally on fleek, are inked head-to-toe in intracate and geneally fucking crazy tattoos, and can kick your ass using psychic powers. I don't even really know what crimes they commit, all I see them do is get drunk in the ramen bars in their shopping center, beat the shit out of each other and passerbys, and go on romantic adventures to kill westerners and other degenerate races. What's not to like? This gang is not to be confused with the Yellow Yakuza, which has way more members. This street connects back into South Sleezeborough. This street is connected to Huntington Avenue, Little Italy, and Cartel Turf.",
        channel = "little-tokyo",
        major_role = "southsleezeborough_major",
        minor_role = "southsleezeboroughstreetc_minor",
        permissions = {'southsleezeboroughstreetc': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "southsleezeborough",
        neighbors = {'southsleezeborough': 20, 'southsleezeboroughstreetb': 20, 'southsleezeboroughstreetd': 20, 'krakbaystreetd': 20},
        wikipage = "https://rfck.miraheze.org/wiki/South_Sleezeborough#Little_Tokyo",
    ),
    EwPoi(
        id_poi = "southsleezeboroughstreetd",
        alias = ['cartelturf', 'cartel'],
        str_name = "Cartel Turf",
        str_desc = "Watch your step pendejo, you are entering what it might look just like a simple shanty town, a modest assortment of short square houses of all kinds of warm colors ripped right out of the bowels of south america, but take a second look, cuz its Los Amontonados' turf, a conglomerate of all the latin drug cartels that ever existed, now reformed into a group of good willed hard workers that fight by fist and gun for the right of the average citizen to snort all the meth their money can buy. The area was built with the thought of reminding their people of the home they left behind in order to fight for what is right and high, but it's also a complex distribution network like no other. Do not fuck with these guys' abuelitas, because they can smuggle cocaine and bullet lead into your soup in seconds, conchatumadre. This street connects back into South Sleezeborough. This street is connected to Festival Grounds, Chinatown, and Little Tokyo.",
        channel = "cartel-turf",
        major_role = "southsleezeborough_major",
        minor_role = "southsleezeboroughstreetd_minor",
        permissions = {'southsleezeboroughstreetd': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "southsleezeborough",
        neighbors = {'southsleezeborough': 20, 'southsleezeboroughstreetc': 20, 'southsleezeboroughstreeta': 20, 'oozegardensstreeta': 20, 'southwestoutskirtsedge': 60},
        wikipage = "https://rfck.miraheze.org/wiki/South_Sleezeborough#Cartel_Turf",
    ),
    EwPoi(
        id_poi = "northsleezeboroughstreeta",
        alias = ['drive-bydrive-thrus', 'drivebydrivethrus', 'driveby', 'drive-by', 'drivethrus', 'drive-thrusdrive'],
        str_name = "Drive-By Drive-Thrus",
        str_desc = "This intersection is packed with every fast food chain you can name. You can't honestly expect the locals of North Sleezeborough to have the mental/physical capabilities of caring about anything enough to get out of their car to do it, so the front doors of these establishments are rusted over and boarded up, while the line for the drive-thru extends down the block. Of course, some of these cars aren't patiently waiting to acquire their extra large value meals, they're just itching to get to the window and rob the place blind, lest they get medieval on the teller's ass with their cruel and unusual instruments. Good times, good times. This street connects back into North Sleezeborough. This street is connected to The Mall, WWW Ring, and Slob Plaza.",
        channel = "drive-by-drive-thrus",
        major_role = "northsleezeborough_major",
        minor_role = "northsleezeboroughstreeta_minor",
        permissions = {'northsleezeboroughstreeta': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "northsleezeborough",
        neighbors = {'northsleezeborough': 20, 'northsleezeboroughstreete': 20, 'northsleezeboroughstreetb': 20, 'krakbaystreete': 20},
        wikipage = "https://rfck.miraheze.org/wiki/North_Sleezeborough#Drivey-By_Drive-Thrus",
    ),
        EwPoi(
        id_poi = "wreckingtonstreeta",
        alias = ['permanentconstructionzone', 'permanentconstruction', 'constructionzone', 'construction'],
        str_name = "Permanent Construction Zone",
        str_desc = "This section of the district is in a permanent state of being haphazardly demolished and rebuilt. A brand new building will be knocked down due to minor plumbing issues and then progress on the remodel will stall for years, and old buildings that don't live up to medieval safety standards have remained standing for a generation. The workers here have gotten so frustrated and bored toiling away here that they invented the ingenious sport of crane jousting to pass the time. This street connects back into Wreckington. This street is connected to The End Lines, and The Scrapyard. This street also exits into The Wreckington Subway Station",
        channel = "permanent-construction-zone",
        major_role = "wreckington_major",
        minor_role = "wreckingtonstreeta_minor",
        permissions = {'wreckingtonstreeta': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "wreckington",
        neighbors = {'wreckington': 20, 'wreckingtonstreetb': 20, 'cratersvillestreeta': 20, 'southoutskirtsedge': 60, 'wreckingtonsubwaystation': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Wreckington#Permanent_Construction_Zone",
    ),
    EwPoi(
        id_poi = "wreckingtonstreetb",
        alias = ['thescrapyard', 'scrapyard'],
        str_name = "The Scrapyard",
        str_desc = "This huge fucking pile of useless junk is the city's dump. After the residents of the surrounding districts realized that Wreckington wasn't going to clean up after its own frequent demolitions, they figured those sites would be the perfect place to throw their trash. Over time it grew and grew, to the point where you can see the borders of multiple neighboring districts from the summit. This street connects back into Wreckington. This street is connected to Rowdy Roughhouse, and Permanent Construction Zone. This street also exits into The Smoker's Cough, The Wreckington Ferry Port, and The Wreckington Subway Station.",
        channel = "the-scrapyard",
        major_role = "wreckington_major",
        minor_role = "wreckingtonstreetb_minor",
        permissions = {'wreckingtonstreetb': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "wreckington",
        neighbors = {'wreckington': 20, 'wreckingtonstreeta': 20, 'rowdyroughhouse': 20, 'southoutskirtsedge': 60, 'smokerscough': 20, 'wreckingtonport': 20, 'wreckingtonsubwaystation': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Wreckington#The_Scrapyard",
    ),
     EwPoi(
        id_poi = "cratersvillestreeta",
        alias = ['theendlines', 'endlines', 'endline'],
        str_name = "The End Lines",
        str_desc = "This street seems remarkably more put together than its neighboring thoroughfares. During the original boom of bright eyed miners flocking to the streets in search of slime it was quickly found to be lacking in the slime and as such was quickly abandoned. This has allowed the locals to keep a sliver of their buildings standing, for the time being at least. This street connects back into Cratersville. This street is connected to The Caldera, Dynamite Lane, and Permanent Construction Zone.",
        channel = "the-end-lines",
        major_role = "cratersville_major",
        minor_role = "cratersvillestreeta_minor",
        permissions = {'cratersvillestreeta': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "cratersville",
        neighbors = {'cratersville': 20, 'cratersvillestreetb': 20, 'cratersvillestreetc': 20, 'wreckingtonstreeta': 20, 'southoutskirtsedge': 60},
        wikipage = "https://rfck.miraheze.org/wiki/Cratersville#The_End_Lines",
    ),
    EwPoi(
        id_poi = "cratersvillestreetb",
        alias = ['thecaldera', 'caldera'],
        str_name = "The Caldera",
        str_desc = "This is Cratersviller's first crater, and widely recognized as its biggest one too. A shipment of TNT got intercepted by gangs and accidentally blew a gigantic hole into the ground. It revealed amazing slime deposits, and so people quickly mined it dry and began tearing up the rest of the district. This street connects back into Cratersville. This street is connected to Drain Trench, The End Lines, and Dynamite Lane. This street also exits into The Cratersville Subway Station",
        channel = "the-caldera",
        major_role = "cratersville_major",
        minor_role = "cratersvillestreetb_minor",
        permissions = {'cratersvillestreetb': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "cratersville",
        neighbors = {'cratersville': 20, 'cratersvillestreeta': 20, 'cratersvillestreetc': 20, 'draintrench': 20, 'cratersvillesubwaystation': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Cratersville#The_Caldera",
    ),
    EwPoi(
        id_poi = "cratersvillestreetc",
        alias = ['dynamitelane', 'dynamite'],
        str_name = "Dynamite Lane",
        str_desc = "This street, if you can even still call it that, looks like the surface of the goddamn moon. Hundreds, possibly even thousands of small to medium sized craters have been punched into the landscape. Presumably the vast majority of these holes revealed no slime, but the fact that there are so many means that people believed that they could strike it rich with even shallow, surface level mining. So, presumably some people did find large veins of slime just under the sidewalk. Kind of makes you want to whip out your pick and start mining, doesn't it? This street connects back into Cratersville. This street is connected to The End Lines, The Caldera, and NLACakaNM Zoo. This street also exits into The Cratersville Mines, and The Cratersville Subway Station.",
        channel = "dynamite-lane",
        major_role = "cratersville_major",
        minor_role = "cratersvillestreetc_minor",
        permissions = {'cratersvillestreetc': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "cratersville",
        neighbors = {'cratersville': 20, 'cratersvillestreeta': 20, 'cratersvillestreetb': 20, 'oozegardensstreetd': 20, 'southoutskirtsedge': 60, 'cratersvillemines': 20, 'cratersvillesubwaystation': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Cratersville#Dynamite_Lane",
    ),
        EwPoi(
        id_poi = "poudrinalleystreeta",
        alias = ['24karatshopping', '24karat', '24'],
        str_name = "24 Karat Shopping",
        str_desc = "It's a couple of decades old small shopping center which used to hold all the small businesses of the zone, the only building in the area that makes actual fucking sense. Nowadays, it is a shadow of its former self after being completely smashed by gangsters and juvies alike. Its few surviving shops remain in the midst of wreckage and extreme vandalism. A structurally relaxing oasis in this maze of a district, lost gangsters usually take a breath here and talk business with the local dealers. This street connects back into Poudrin Alley. This street is connected to Rowdy Roughhouse, Apartment Complex, and Drain Trench. This street also exits into The Poudrin Alley Subway Station",
        channel = "24-karat-shopping",
        major_role = "poudrinalley_major",
        minor_role = "poudrinalleystreeta_minor",
        permissions = {'poudrinalleystreeta': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "poudrinalley",
        neighbors = {'poudrinalley': 20, 'draintrench': 20, 'poudrinalleystreetb': 20, 'rowdyroughhouse': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Poudrin_Alley#24_Karat_Shopping",
    ),
    EwPoi(
        id_poi = "poudrinalleystreetb",
        alias = ['apartmentcomplex', 'complex'],
        str_name = "Apartment Complex",
        str_desc = "You're balls-deep inside of one of Poudrin Alley's infamous apartment complexes. This section is particularly labyrinthine, being made up of tight corridors with poor lighting and drainage. You have no idea how the locals navigate this shit. This street connects back into Poudrin Alley. This street is connected to The Common, 24 Karat Shopping, and Abandoned Intersection. This street also exits into Outside the 7-11",
        channel = "apartment-complex",
        major_role = "poudrinalley_major",
        minor_role = "poudrinalleystreetb_minor",
        permissions = {'poudrinalleystreetb': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "poudrinalley",
        neighbors = {'poudrinalley': 20, 'poudrinalleystreeta': 20, 'poudrinalleystreetc': 20, 'downtownstreetd': 20, 'outsidethe711': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Poudrin_Alley#Apartment_Complex",
    ),
    EwPoi(
        id_poi = "poudrinalleystreetc",
        alias = ['abandonedintersection', 'intersection'],
        str_name = "Abandoned Intersection",
        str_desc = "This four-way intersection is one of the few points of interest in the district that isn't hidden away in some obscure alleyway or backstreet. This crossroads is home to a few sketchy take-out restaurants, a gas station, and a few foreclosed businesses. This street connects back into Poudrin Alley. This street is connected to Minotaur Square, Apartment Complex, and Skewer Road.",
        channel = "abandoned-intersection",
        major_role = "poudrinalley_major",
        minor_role = "poudrinalleystreetc_minor",
        permissions = {'poudrinalleystreetc': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "poudrinalley",
        neighbors = {'poudrinalley': 20, 'poudrinalleystreetb': 20, 'poudrinalleystreetd': 20, 'krakbaystreetb': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Poudrin_Alley#Abandoned_Intersection",
    ),
    EwPoi(
        id_poi = "poudrinalleystreetd",
        alias = ['skewerroad', 'skewer'],
        str_name = "Skewer Road",
        str_desc = "It's a dead-end zig-zag road in ruins that has more turns and pointy corners than an Speed Racer episode of him running from bulls. This road It's the only access to a lot of the houses in the district, you could call it one long, crooked alleway. It remained unattended for so long that everything ended up all cracked and bent. People commute everyday through this road every day in the form of a slow ballet-like traffic, trying to avoid getting their toes shaved by the sharp erupted asphalt, getting impaled by a broken streetlight or eaten entirely by a pothole, like many other less fortunate neighbors. This street connects back into Poudrin Alley. This street is connected to Abandoned Intersection, Drain Trench, and Museum Row.",
        channel = "skewer-road",
        major_role = "poudrinalley_major",
        minor_role = "poudrinalleystreetd_minor",
        permissions = {'poudrinalleystreetd': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "poudrinalley",
        neighbors = {'poudrinalley': 20, 'poudrinalleystreetc': 20, 'draintrench': 20, 'oozegardensstreetc': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Poudrin_Alley#Skewer_Road",
    ),

        EwPoi(
        id_poi = "krakbaystreetf",
        alias = ['goldengunkbridge', 'goldengunk', 'golden'],
        str_name = "Golden Gunk Bridge",
        str_desc = "It's one of the main exits out of Krak Bay, a bridge over the slimy waters that U turns around in a perfect 180 back to the coastland. It was initially built to connect the bay and the area now known today as Cop Killtown, but then the vicious gang showed up, so construction was halted and then repurposed into one of the most stupid structures ever made. Its name comes from the yellow hue that the fungus growing on there gives to the bridge. This street connects back into Krak Bay. This street is connected to Esplanade, The Mall, and Police Station.",
        channel = "golden-gunk-bridge",
        major_role = "krakbay_major",
        minor_role = "krakbaystreetf_minor",
        permissions = {'krakbaystreetf': ['read', 'send', 'connect']},
        property_class = "a",
        is_street = True,
        father_district = "krakbay",
        neighbors = {'krakbay': 20, 'krakbaystreete': 20, 'krakbaystreeta': 20, 'glocksburystreeta': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Krak_Bay#Golden_Gunk_Bridge",
    ),
    EwPoi(
        id_poi = "downtownstreetf",
        alias = ['financialdistrict', 'financial'],
        str_name = "Financial District",
        str_desc = "You gaze up at the modern skyscrapers and sleek condos above you. This is where robber barons of all shapes and sizes come up with cool and new ways to exploit the unwashed masses, and to wring as much slime out of the earth as humanly possible. Nice. This street connects back into Downtown NLACakaNM. This street is connected to Cop Killtown, North End, and Combat Zone.",
        channel = "financial-district",
        major_role = "downtown_major",
        minor_role = "downtownstreetf_minor",
        permissions = {'downtownstreetf': ['read', 'send', 'connect']},
        property_class = "s",
        is_street = True,
        father_district = "downtown",
        neighbors = {'downtown': 20, 'downtownstreete': 20, 'downtownstreeta': 20, 'copkilltown': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Downtown_NLACakaNM#Financial_District",
    ),
    EwPoi(
        id_poi = "krakbaystreeta",
        alias = ['esplanade'],
        str_name = "Esplanade",
        str_desc = "This long sidewalk follows the bend of the River of Slime, all the way from Downtown to West Glocksbury. However, the only valuable stretch of it is here in Krak Bay due to the stores on the other side of the street. This street connects back into Krak Bay. This street is connected to Combat Zone, Minotaur Square, and Golden Gunk Bridge. This street also exits into The Krak Bay Subway Station",
        channel = "esplanade",
        major_role = "krakbay_major",
        minor_role = "krakbaystreeta_minor",
        permissions = {'krakbaystreeta': ['read', 'send', 'connect']},
        property_class = "a",
        is_street = True,
        father_district = "krakbay",
        neighbors = {'krakbay': 20, 'krakbaystreetf': 20, 'krakbaystreetb': 20, 'downtownstreete': 20, 'krakbaysubwaystation': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Krak_Bay#Esplanade",
    ),
    EwPoi(
        id_poi = "krakbaystreetb",
        alias = ['minotaursquare', 'minotaur'],
        str_name = "Minotaur Square",
        str_desc = "It's a small park in the center of the district, home to a weekly farmer's market and a handful of seasonal events. Most of the time, though, it's just a place to take a quick breather before heading back to do more shopping. In the center is a statue of friendly mythological half-beast, and inscribed in a plaque next to it is inscribed the words 'dedicated to https://twitter.com/krakissi' This street connects back into Krak Bay. This street is connected to Esplanade, Goobury Street, and Abandoned Intersection.",
        channel = "minotaur-square",
        major_role = "krakbay_major",
        minor_role = "krakbaystreetb_minor",
        permissions = {'krakbaystreetb': ['read', 'send', 'connect']},
        property_class = "a",
        is_street = True,
        father_district = "krakbay",
        neighbors = {'krakbay': 20, 'krakbaystreeta': 20, 'krakbaystreetc': 20, 'poudrinalleystreetc': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Krak_Bay#Minotaur_Square",
    ),
    EwPoi(
        id_poi = "krakbaystreetc",
        alias = ['gooburystreet', 'goobury'],
        str_name = "Goobury Street",
        str_desc = "This street runs through the majority of the district, and is home to countless restaurants and stores. You'll find actually affordable stuff over by the border with Glocksbury, with bourgeois luxuries popping up more frequently the farther east you go. This street connects back into Krak Bay. This street is connected to Minotaur Square, Huntington Avenue, and Wine Gardens.",
        channel = "goobury-street",
        major_role = "krakbay_major",
        minor_role = "krakbaystreetc_minor",
        permissions = {'krakbaystreetc': ['read', 'send', 'connect']},
        property_class = "a",
        is_street = True,
        father_district = "krakbay",
        neighbors = {'krakbay': 20, 'krakbaystreetb': 20, 'krakbaystreetd': 20, 'oozegardensstreetb': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Krak_Bay#Goobury_Street",
    ),
    EwPoi(
        id_poi = "krakbaystreetd",
        alias = ['huntingtonavenue', 'huntington'],
        str_name = "Huntington Avenue",
        str_desc = "It's a wide boulevard, still featuring the old streetcar tracks running down the center of the road. This is a fairly stagnant corner of Krak Bay; everything that hasn't gone out of business has been here for a very, very long time. This street connects back into Krak Bay. This street is connected to Goobury Street, The Mall, and Little Tokyo. This street also exits into The NLACakaNM Food Court",
        channel = "huntington-avenue",
        major_role = "krakbay_major",
        minor_role = "krakbaystreetd_minor",
        permissions = {'krakbaystreetd': ['read', 'send', 'connect']},
        property_class = "a",
        is_street = True,
        father_district = "krakbay",
        neighbors = {'krakbay': 20, 'krakbaystreetc': 20, 'krakbaystreete': 20, 'southsleezeboroughstreetc': 20, 'thefoodcourt': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Krak_Bay#Huntington_Avenue",
    ),
    EwPoi(
        id_poi = "downtownstreeta",
        alias = ['northend', 'north'],
        str_name = "North End",
        str_desc = "This is one of the older neighborhoods in the city, and as such the apartments here show some wear-and-tear. This street connects back into Downtown NLACakaNM. This street is connected to the Waterfront, Financial District, and Sludge Refinery.",
        channel = "north-end",
        major_role = "downtown_major",
        minor_role = "downtownstreeta_minor",
        permissions = {'downtownstreeta': ['read', 'send', 'connect']},
        property_class = "s",
        is_street = True,
        father_district = "downtown",
        neighbors = {'downtown': 20, 'downtownstreetf': 20, 'downtownstreetb': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Downtown_NLACakaNM#North_End",
    ),
    EwPoi(
        id_poi = "downtownstreetb",
        alias = ['waterfront', 'water'],
        str_name = "the Waterfront",
        str_desc = "This stretch of coast is home to the city's original wharf. It's long since fallen out of use as an actual dockyard in favor of Vagrant's Corner, but still lives on as a tourist trap full of easily pickpocketed out-of-towners who want to stare out at the Slime Sea through a tower viewer. This street connects back into Downtown NLACakaNM. This street is connected to North End, Downtown Crossing, and The Strip.",
        channel = "waterfront",
        major_role = "downtown_major",
        minor_role = "downtownstreetb_minor",
        permissions = {'downtownstreetb': ['read', 'send', 'connect']},
        property_class = "s",
        is_street = True,
        father_district = "downtown",
        neighbors = {'downtown': 20, 'downtownstreeta': 20, 'downtownstreetc': 20, 'greenlightdistrictstreetc': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Downtown_NLACakaNM#Waterfront",
    ),
    EwPoi(
        id_poi = "downtownstreetc",
        alias = ['downtowncrossing', 'crossing'],
        str_name = "Downtown Crossing",
        str_desc = "This intersection is a bustling outdoor pedestrian shopping mall full of department stores, restaurants, specialty retailers, and more. Sketchy street vendors peddle their wares to all who will listen. This street connects back into Downtown NLACakaNM. This street is connected to Rowdy Roughhouse, the Waterfront, and The Common.",
        channel = "downtown-crossing",
        major_role = "downtown_major",
        minor_role = "downtownstreetc_minor",
        permissions = {'downtownstreetc': ['read', 'send', 'connect']},
        property_class = "s",
        is_street = True,
        father_district = "downtown",
        neighbors = {'downtown': 20, 'downtownstreetd': 20, 'downtownstreetb': 20, 'rowdyroughhouse': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Downtown_NLACakaNM#Downtown_Crossing",
    ),
    EwPoi(
        id_poi = "downtownstreetd",
        alias = ['thecommon', 'common'],
        str_name = "The Common",
        str_desc = "It's a public park established in the early years of the city. It's basically just a patch of dead grass; all the fountains and monuments were defaced years ago. This street connects back into Downtown NLACakaNM. This street is connected to Downtown Crossing, Combat Zone, and Apartment Complex. This street also exits into The Downtown NLACakaNM Subway Station",
        channel = "the-common",
        major_role = "downtown_major",
        minor_role = "downtownstreetd_minor",
        permissions = {'downtownstreetd': ['read', 'send', 'connect']},
        property_class = "s",
        is_street = True,
        father_district = "downtown",
        neighbors = {'downtown': 20, 'downtownstreetc': 20, 'downtownstreete': 20, 'poudrinalleystreetb': 20, 'downtownsubwaystation': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Downtown_NLACakaNM#The_Common",
    ),
     EwPoi(
        id_poi = "brawldenstreetb",
        alias = ['brownstonerow', 'brownstone'],
        str_name = "Brownstone Row",
        str_desc = "This row of brownstone three-decker townhouses isn't particularly special or noteworthy in any regards. This street connects back into Brawlden. This street is connected to Abandoned Warehouse, Brawlden Private School District, and Concrete Park.",
        channel = "brownstone-row",
        major_role = "brawlden_major",
        minor_role = "brawldenstreetb_minor",
        permissions = {'brawldenstreetb': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "brawlden",
        neighbors = {'brawlden': 20, 'brawldenstreeta': 20, 'brawldenstreetc': 20, 'newnewyonkersstreeta': 20, 'northoutskirtsedge': 60},
        wikipage = "https://rfck.miraheze.org/wiki/Brawlden#Brownstone_Row",
    ),
        EwPoi(
        id_poi = "littlechernobylstreeta",
        alias = ['halfliferoad', 'halflife'],
        str_name = "Half-Life Road",
        str_desc = "This road has such high densities of concerted radiation that technically speaking you instantly die as soon as you step on it. Thankfully, the slime works in mysterious ways and your god-defying pseudo-corpse continues to be propped up by your ''consciousness'' for the remainder of your short, sad life. You're neither alive nor dead. You're in a sort of' Wait for it' Team Fortress 2. Haha, G-Man!! This street connects back into Little Chernobyl. This street is connected to Riverbank, Reactor Ground Zero, and Bombed-Out Buildings. This street also exits into The Little Chernobyl Subway Station",
        channel = "half-life-road",
        major_role = "littlechernobyl_major",
        minor_role = "littlechernobylstreeta_minor",
        permissions = {'littlechernobylstreeta': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "littlechernobyl",
        neighbors = {'littlechernobyl': 20, 'littlechernobylstreetc': 20, 'littlechernobylstreetb': 20, 'arsonbrookstreete': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Little_Chernobyl#Half-Life_Road",
    ),
    EwPoi(
        id_poi = "littlechernobylstreetc",
        alias = ['bombedoutbuildings', 'bombedout', 'bombed', 'bombed-outbuildings', 'bombed-out'],
        str_name = "Bombed-Out Buildings",
        str_desc = "These old, barely standing apartment buildings used to be prime real estate before everything went to shit. Well, more like before anything went to slime, aka got infinitely better and way cooler. They've still got a nice location overlooking the River of Slime, but everything looks super gross so no one wants to move back in and no one really gives enough of a shit to demolish what's left and rebuild from scratch. This street connects back into Little Chernobyl. This street is connected to Half-Life Road, Reactor Ground Zero, and Old Folks Home.",
        channel = "bombed-out-buildings",
        major_role = "littlechernobyl_major",
        minor_role = "littlechernobylstreetc_minor",
        permissions = {'littlechernobylstreetc': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "littlechernobyl",
        neighbors = {'littlechernobyl': 20, 'littlechernobylstreetb': 20, 'littlechernobylstreeta': 20, 'oldnewyonkersstreetb': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Little_Chernobyl#Bombed-Out_Buildings",
    ),
    EwPoi(
        id_poi = "oldnewyonkersstreeta",
        alias = ['usurylane', 'usury'],
        str_name = "Usury Lane",
        str_desc = "This satanic manifestation of hell on earth is a perfectly normal road that has been overrun by extortionate loaning agencies and mortgage financiers. Their interest rates are so absurd that more or less any loan you take out will render you a literal slave before you're able to make your first payment. You'll have deserved it, too. This street connects back into Old New Yonkers. This street is connected to Factory Row, Old Folks Home, and Morty Hill.",
        channel = "usury-lane",
        major_role = "oldnewyonkers_major",
        minor_role = "oldnewyonkersstreeta_minor",
        permissions = {'oldnewyonkersstreeta': ['read', 'send', 'connect']},
        property_class = "a",
        is_street = True,
        father_district = "oldnewyonkers",
        neighbors = {'oldnewyonkers': 20, 'oldnewyonkersstreete': 20, 'oldnewyonkersstreetb': 20, 'smogsburgstreete': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Old_New_Yonkers#Usury_Lane",
    ),
    EwPoi(
        id_poi = "oldnewyonkersstreetb",
        alias = ['oldfolkshome', 'oldfolks'],
        str_name = "Old Folks Home",
        str_desc = "This street is home to a building that sits apart from the seemingly endless rows of houses filling your view. Depression seems to ooze from the very sight of the complex. The front of the building greets you with various types of lawn ornaments. Nothing much seems to go on here. It's said if you're very lucky you may see one of its residents leaving the home to yell at kids for coming within spitting distance of the lawn. This street connects back into Old New Yonkers. This street is connected to Bombed-Out Buildings, Usury Lane, and Luxury Townhouses.",
        channel = "old-folks-home",
        major_role = "oldnewyonkers_major",
        minor_role = "oldnewyonkersstreetb_minor",
        permissions = {'oldnewyonkersstreetb': ['read', 'send', 'connect']},
        property_class = "a",
        is_street = True,
        father_district = "oldnewyonkers",
        neighbors = {'oldnewyonkers': 20, 'oldnewyonkersstreeta': 20, 'oldnewyonkersstreetc': 20, 'littlechernobylstreetc': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Old_New_Yonkers#Old_Folks_Home",
    ),
    EwPoi(
        id_poi = "oldnewyonkersstreetd",
        alias = ['shoppingcenter', 'shopping'],
        str_name = "Shopping Center",
        str_desc = "It's just some normal, boring parking lot shopping center. There's a bunch of chain family restaurants and soulless department stores. Grandparents are out and about, presumably buying candles, greeting cards, and other useless shit no one actually needs. You are disgusted. This street connects back into Old New Yonkers. This street is connected to Luxury Townhouses, Morty Hill, and Single Gentrified Street.",
        channel = "shopping-center",
        major_role = "oldnewyonkers_major",
        minor_role = "oldnewyonkersstreetd_minor",
        permissions = {'oldnewyonkersstreetd': ['read', 'send', 'connect']},
        property_class = "a",
        is_street = True,
        father_district = "oldnewyonkers",
        neighbors = {'oldnewyonkers': 20, 'oldnewyonkersstreetc': 20, 'oldnewyonkersstreete': 20, 'newnewyonkersstreetd': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Old_New_Yonkers#Shopping_Center",
    ),
    EwPoi(
        id_poi = "newnewyonkersstreeta",
        alias = ['concretepark', 'concrete'],
        str_name = "Concrete Park",
        str_desc = "This urban park is a common gathering place for locals to come, hang out, watch street performances, and play games. Now, this is New New Yonkers, so there are a few quirks of the culture. For instance, even though there are a few basketball courts here, no one actually plays basketball (at least, using the official ruleset). Here, games like that are just an excuse to pick a fight with people so you can bash their skull in with a casus belli. It's pretty cool. Also, all of the buskers are fucking metal, doing insane tricks that extert their body to their absolute limit for the promise of some slime tips. Often, buskers just fucking die because they've encased themselves in metal or something for the crowd's sick enjoyment. This street connects back into New New Yonkers. This street is connected to Brownstone Row, Broadway, and Single Gentrified Street. This street also exits into The New New Yonkers Subway Station",
        channel = "concrete-park",
        major_role = "newnewyonkers_major",
        minor_role = "newnewyonkersstreeta_minor",
        permissions = {'newnewyonkersstreeta': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "newnewyonkers",
        neighbors = {'newnewyonkers': 20, 'newnewyonkersstreetd': 20, 'newnewyonkersstreetb': 20, 'brawldenstreetb': 20, 'northoutskirtsedge': 60},
        wikipage = "https://rfck.miraheze.org/wiki/New_New_Yonkers#Concrete_Park",
    ),
    EwPoi(
        id_poi = "newnewyonkersstreetb",
        alias = ['broadway'],
        str_name = "Broadway",
        str_desc = "This street has the best nightlife in the entire city. This shit is wild. There are a thousand different bars, almost all featuring bartenders operating without a license and making shit that send people to another plane of existence, there are all manner of arcades, escape rooms and other novelties to keep you entertained, and that's not even to mention all of the restaurants for you to go and gorge on more food and drinks. With all of the drunk people with adrenaline pumping through their veins and zero responsible thoughts through their brain, fights often break out and bubble over into all out gang wars. This place is like the Fall of Rome, all night, every night. This street connects back into New New Yonkers. This street is connected to Concrete Park, Ghetto Townhouses, and Paradise Slums.",
        channel = "broadway",
        major_role = "newnewyonkers_major",
        minor_role = "newnewyonkersstreetb_minor",
        permissions = {'newnewyonkersstreetb': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "newnewyonkers",
        neighbors = {'newnewyonkers': 20, 'newnewyonkersstreeta': 20, 'newnewyonkersstreetc': 20, 'assaultflatsbeachstreeta': 20, 'northoutskirtsedge': 60},
        wikipage = "https://rfck.miraheze.org/wiki/New_New_Yonkers#Broadway",
    ),
    EwPoi(
        id_poi = "newnewyonkersstreetc",
        alias = ['ghettotownhouses', 'ghetto'],
        str_name = "Ghetto Townhouses",
        str_desc = "This residential neighborhood is just about as rough-'n'-tumble as you can get. Half the windows are boarded up, graffiti's been sprayed over half the block, and every night some house party is thrown that requires loud as fuck music and drunk people jumping off roofs and strangling bystanders for fun. Hell yeah!! This street connects back into New New Yonkers. This street is connected to Broadway, Single Gentrified Street, and Cockfight Backstreet.",
        channel = "ghetto-townhouses",
        major_role = "newnewyonkers_major",
        minor_role = "newnewyonkersstreetc_minor",
        permissions = {'newnewyonkersstreetc': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "newnewyonkers",
        neighbors = {'newnewyonkers': 20, 'newnewyonkersstreetb': 20, 'newnewyonkersstreetd': 20, 'vagrantscornerstreetf': 20},
        wikipage = "https://rfck.miraheze.org/wiki/New_New_Yonkers#Ghetto_Townhouses",
    ),
    EwPoi(
        id_poi = "newnewyonkersstreetd",
        alias = ['singlegentrifiedstreet', 'singlegentrified', 'single'],
        str_name = "Single Gentrified Street",
        str_desc = "This is the only normal, safe street in the district. So, it makes sense that it borders Old New Yonkers. There's not much to say, this place is really fucking boring. There's no gunshots ringing off in the distance, no graffiti on the sidewalks or fights breaking out. It just sucks. This street connects back into New New Yonkers. This street is connected to Shopping Center, Concrete Park, and Ghetto Townhouses.",
        channel = "single-gentrified-street",
        major_role = "newnewyonkers_major",
        minor_role = "newnewyonkersstreetd_minor",
        permissions = {'newnewyonkersstreetd': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "newnewyonkers",
        neighbors = {'newnewyonkers': 20, 'newnewyonkersstreetc': 20, 'newnewyonkersstreeta': 20, 'oldnewyonkersstreetd': 20},
        wikipage = "https://rfck.miraheze.org/wiki/New_New_Yonkers#Single_Gentrified_Street",
    ),
    EwPoi(
        id_poi = "assaultflatsbeachstreetb",
        alias = ['beachfrontproperties', 'beachfront'],
        str_name = "Beachfront Properties",
        str_desc = "This stretch of beach is probably the only part of the city you could actually consider kind of pretty. It's almost entirely privately owned by the resort, which has gobbled up most of the valuable coastline to either develop or charge access to, but some luxury condominiums have been built here and there. These condominiums are subject to frequent raiding by S.W.A.T. teams to make sure the peace is kept. This street connects back into Assault Flats Beach. This street is connected to Paradise Slums, and Long Wharf. This street also exits into Assault Flats Beach Pier, and Nuclear Beach Edge.",
        channel = "beachfront-properties",
        major_role = "assaultflatsbeach_major",
        minor_role = "assaultflatsbeachstreetb_minor",
        permissions = {'assaultflatsbeachstreetb': ['read', 'send', 'connect']},
        property_class = "s",
        is_street = True,
        father_district = "assaultflatsbeach",
        neighbors = {'assaultflatsbeach': 20, 'assaultflatsbeachstreeta': 20, 'vagrantscornerstreeta': 20, 'nuclearbeachedge': 20, 'assaultflatsbeachpier': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Assault_Flats_Beach#Beachfront_Properties",
    ),
    EwPoi(
        id_poi = "vagrantscornerstreeta",
        alias = ['longwharf', 'long', 'wharf'],
        str_name = "Long Wharf",
        str_desc = "This harbor is one of the keys to the city's success. Several wharves extend out into the sea with various merchant vessels and privateers docked on them, unloading their booty and letting their crew rest before the next voyage. The goods are being carried off to be sold all across the city, though a lot will stay in the district and be sold at the marketplace. It's because of these cargo ships, with trade routes that extend across the entire slime sea, that NLACakaNM is the maritime power and prosperous city upon a hill that it is today. This street connects back into Vagrant's Corner. This street is connected to Beachfront Properties, The Dockyard, and Cockfight Backstreet. This street also exits into The Vagrant's Corner Ferry Port, and The Vagrant's Corner Subway Station.",
        channel = "long-wharf",
        major_role = "vagrantscorner_major",
        minor_role = "vagrantscornerstreeta_minor",
        permissions = {'vagrantscornerstreeta': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "vagrantscorner",
        neighbors = {'vagrantscorner': 20, 'vagrantscornerstreetf': 20, 'vagrantscornerstreetb': 20, 'assaultflatsbeachstreetb': 20, 'vagrantscornerport': 20, 'vagrantscornersubwaystation': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Vagrant's_Corner#Long_Wharf",
    ),
    EwPoi(
        id_poi = "vagrantscornerstreetb",
        alias = ['thedockyard', 'dockyard'],
        str_name = "The Dockyard",
        str_desc = "This is where the city's fleet is built, upgraded, and replaced year in, year out. Without privateers sailing the slime sea, protecting our cargo ships and boarding those of our rivals, the city wouldn't be able to project nearly as much power as it does today. This shipyard is a true engineering marvel, as it's able to turn out new ships at breakneck speeds. Which is good, because dumbasses keep wrecking them. Guess that's what happens when you slime under the influence (of slime). This street connects back into Vagrant's Corner. This street is connected to Long Wharf, Pubcrawl Road, and Sandy Neck. This street also exits into The Vagrant's Corner Ferry Port",
        channel = "the-dockyard",
        major_role = "vagrantscorner_major",
        minor_role = "vagrantscornerstreetb_minor",
        permissions = {'vagrantscornerstreetb': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "vagrantscorner",
        neighbors = {'vagrantscorner': 20, 'vagrantscornerstreeta': 20, 'vagrantscornerstreetc': 20, 'slimesendstreeta': 20, 'vagrantscornerport': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Vagrant's_Corner#The-Dockyard",
    ),
    EwPoi(
        id_poi = "vagrantscornerstreetc",
        alias = ['pubcrawlroad', 'pubcrawl'],
        str_name = "Pubcrawl Road",
        str_desc = "This cobblestone road is almost entirely made up of pubs, it's pubs as far as the eye can see. Any sailor who's been a sailor for long enough will more likely than not spend the majority of their nights here, hopping from tavern to tavern to enjoy the warm embrace of their cheap beer and even worse food. If you stay out late enough, you'll see dunkards passed out on the side of the road, or stumbling home. Alcoholism is pretty good, actually. It's aesthetic. This street connects back into Vagrant's Corner. This street is connected to Juvie's Row, The Dockyard, and Seaside Market.",
        channel = "pubcrawl-road",
        major_role = "vagrantscorner_major",
        minor_role = "vagrantscornerstreetc_minor",
        permissions = {'vagrantscornerstreetc': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "vagrantscorner",
        neighbors = {'vagrantscorner': 20, 'vagrantscornerstreetb': 20, 'vagrantscornerstreetd': 20, 'juviesrow': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Vagrant's_Corner#Pubcrawl_Road",
    ),
    EwPoi(
        id_poi = "vagrantscornerstreetd",
        alias = ['seasidemarket', 'seaside'],
        str_name = "Seaside Market",
        str_desc = "This is where a good chunk of the goods captured or traded for from the across the slime sea end up. There's exotic vegetables and fish from far off cities, strange weapons and writings, as well as tacky souvenirs and merchandise from a semi-mythical land the natives refer to as 'the State of Arizonia'. Crazy stuff, huh? If you want to buy something, you'll probably have to haggle for it for a while to get a reasonable price. Make sure to speak up when you're doing it, too; this place can get pretty loud. This street connects back into Vagrant's Corner. This street is connected to Pubcrawl Road, Trimountaine, and Seedy Street.",
        channel = "seaside-market",
        major_role = "vagrantscorner_major",
        minor_role = "vagrantscornerstreetd_minor",
        permissions = {'vagrantscornerstreetd': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "vagrantscorner",
        neighbors = {'vagrantscorner': 20, 'vagrantscornerstreetc': 20, 'vagrantscornerstreete': 20, 'greenlightdistrictstreeta': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Vagrant's_Corner#Seaside_Market",
    ),
    EwPoi(
        id_poi = "vagrantscornerstreete",
        alias = ['Trimountaine', 'trimountain', 'tri'],
        str_name = "Trimountaine",
        str_desc = "This corner of the district hasn't been subject to the same heavy development as waterfront, as such there's not a lot to see. The original three hills that gave the region its name still stand, unlike the rest of Vagrant's Corner which has been flattened over the years to accommodate rapid landfill projects. The only structure of importance here is the old lighthouse. It used to guide ships to the harbor before it was quickly outgrown. A newer, taller one was built in Slime's End. This street connects back into Vagrant's Corner. This street is connected to Morty Hill, Seaside Market, and Cockfight Backstreet.",
        channel = "trimountaine",
        major_role = "vagrantscorner_major",
        minor_role = "vagrantscornerstreete_minor",
        permissions = {'vagrantscornerstreete': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "vagrantscorner",
        neighbors = {'vagrantscorner': 20, 'vagrantscornerstreetd': 20, 'vagrantscornerstreetf': 20, 'oldnewyonkersstreete': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Vagrant's_Corner#Trimountaine",
    ),
    EwPoi(
        id_poi = "vagrantscornerstreetf",
        alias = ['cockfightbackstreet', 'cockfight'],
        str_name = "Cockfight Backstreet",
        str_desc = "There's no better way to unwind after being stuck on a boat for months on end like watching animals kill each other. Sailors looking for a night on the town, before or after taking a detour in the Green Light District, will often wind up here where organic and slime-based animals alike go toe-to-toe in gruesome bloodsports. Keep in mind, this ain't your grandma's slimeoid battle. Most of the contestants here are wild beasts, caught from the outskirts or were brought into the city from far, far away. The duels here are chaotic and end in copious amounts of glore getting splattered unto the audience and all over the walls. Fun is had by all. This street connects back into Vagrant's Corner. This street is connected to Ghetto Townhouses, Long Wharf, and Trimountaine.",
        channel = "cockfight-backstreet",
        major_role = "vagrantscorner_major",
        minor_role = "vagrantscornerstreetf_minor",
        permissions = {'vagrantscornerstreetf': ['read', 'send', 'connect']},
        property_class = "c",
        is_street = True,
        father_district = "vagrantscorner",
        neighbors = {'vagrantscorner': 20, 'vagrantscornerstreete': 20, 'vagrantscornerstreeta': 20, 'newnewyonkersstreetc': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Vagrant's_Corner#Cockfight_Backstreet",
    ),
    EwPoi(
        id_poi = "greenlightdistrictstreeta",
        alias = ['seedystreet', 'seedy'],
        str_name = "Seedy Street",
        str_desc = "This prominent backstreet is an open secret to anyone who knows anything. Over here, the really crazy shit happens, the real Sodom and Gomorrah type shit. Of course, Sodom and Gomorrah type shit happens everywhere in this district, we were just running out of space on the strip and couldn't fit in another brothel. This street connects back into Green Light District. This street is connected to Seaside Market, Parking Garage, and The Strip.",
        channel = "seedy-street",
        major_role = "greenlightdistrict_major",
        minor_role = "greenlightdistrictstreeta_minor",
        permissions = {'greenlightdistrictstreeta': ['read', 'send', 'connect']},
        property_class = "a",
        is_street = True,
        father_district = "greenlightdistrict",
        neighbors = {'greenlightdistrict': 20, 'greenlightdistrictstreetc': 20, 'greenlightdistrictstreetb': 20, 'vagrantscornerstreetd': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Green_Light_District#Seedy_Street",
    ),
    EwPoi(
        id_poi = "greenlightdistrictstreetb",
        alias = ['parkinggarage'],
        str_name = "Parking Garage",
        str_desc = "This genuine fucking Tower of Babel has brought together downtrodden lowlifes from across the city and beyond in the torturous pursuit of trying to find a fucking space so the they can finally get out and actually start gambling. Most never make it that far, circling each level endlessly, never finding release. These motherfuckers are pissed, so they might try running you over while you spray your graffiti. This street connects back into Green Light District. This street is connected to Juvie's Row, Seedy Street, and The Strip.",
        channel = "parking-garage",
        major_role = "greenlightdistrict_major",
        minor_role = "greenlightdistrictstreetb_minor",
        permissions = {'greenlightdistrictstreetb': ['read', 'send', 'connect']},
        property_class = "a",
        is_street = True,
        father_district = "greenlightdistrict",
        neighbors = {'greenlightdistrict': 20, 'greenlightdistrictstreeta': 20, 'greenlightdistrictstreetc': 20, 'juviesrow': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Green_Light_District#Parking_Garage",
    ),
    EwPoi(
        id_poi = "slimesendstreeta",
        alias = ['sandyneck', 'sandy'],
        str_name = "Sandy Neck",
        str_desc = "This rough coastline is home to most of the settlements in the district, despite the fact that it is boring as shit and also that all manner of eldritch sea monsters (including but not limited to krakens) are constantly washing ashore and fucking shit up. Yup, life's pretty boring here in Slime's End. Just tag some of the sparse homes here and head back into the city. Home to the city's lighthouse, which guides ships towards Vagrant's Corner all day and all night. This street connects back into Slime's End. This street is connected to The Dockyard This street also exits into Slime's End Pier",
        channel = "sandy-neck",
        major_role = "slimesend_major",
        minor_role = "slimesendstreeta_minor",
        permissions = {'slimesendstreeta': ['read', 'send', 'connect']},
        property_class = "b",
        is_street = True,
        father_district = "slimesend",
        neighbors = {'slimesend': 20, 'vagrantscornerstreetb': 20, 'slimesendpier': 20},
        wikipage = "https://rfck.miraheze.org/wiki/Slime's_End#Sandy_Neck",
    ),


           if (any(swear in content_tolower for swear in ewcfg.curse_words.keys())) and False: #no slimecorp, let's not run through this logic
            # print(content_tolower_list)
            swear_multiplier = 0
            usermodel = EwUser(id_user=message.author.id, id_server=playermodel.id_server)

            if usermodel != None:
                market_data = EwMarket(id_server=usermodel.id_server)

                if usermodel.faction == ewcfg.faction_slimecorp and usermodel.life_state == ewcfg.life_state_enlisted:

                    # gather all the swear words the user typed.
                    for swear in ewcfg.curse_words.keys():

                        swear_count = content_tolower.count(swear)

                        # Niche scenarios. If certain words are used, don't count their components as swears.
                        if swear == "shit" and "shit" not in content_tolower:
                            # print('swear detection turned off for {}.'.format(swear))
                            continue

                        # This one's funny, keep this one on. Bit of a gamer...
                        # elif swear == "fag" and "fag" not in content_tolower:
                        # print('swear detection turned off for {}.'.format(swear))
                        # continue

                        elif swear == "fuck" and (content_tolower.count('<rowdyfucker431275088076079105>') > 0 or content_tolower.count('<fucker431424220837183489>') > 0):
                            # print('swear detection turned off for {}.'.format(swear))
                            continue
                        elif swear == "mick" and (content_tolower.count('gimmick') > 0):
                            # print('swear detection turned off for {}.'.format(swear))
                            continue

                        for i in range(swear_count):
                            swear_multiplier += ewcfg.curse_words[swear]

                        # usermodel.swear_jar += 1

                    # print('multiplier: {}'.format(swear_multiplier))

                    # don't fine the user or send out the message if there weren't enough curse words
                    if swear_multiplier > 10:
                        # fine the user for swearing, based on how much they've sworn right now, as well as in the past
                        swear_jar_fee = swear_multiplier * 10000

                        usermodel.salary_credits -= swear_jar_fee

                        response = '*{}*: Your SlimeCorp headset chatters in your ear...\n"Reminder: Foul language is strictly prohibited. {} salary credits have been docked from your profile."'.format(message.author.display_name, swear_jar_fee)
                        await fe_utils.send_message(client, message.channel, response)

                    market_data.persist()
                    usermodel.persist()


async def rent_time(id_server = None):

	try:
		conn_info = bknd_core.databaseConnect()
		conn = conn_info.get('conn')
		cursor = conn.cursor()
		client = ewutils.get_client()
		if id_server != None:
			#get all players with apartments. If a player is evicted, thir rent is 0, so this will not affect any bystanders.
			cursor.execute("SELECT apartment.rent, users.id_user FROM users INNER JOIN apartment ON users.id_user=apartment.id_user WHERE users.id_server = %s AND apartment.id_server = %s AND apartment.rent > 0".format(

			), (
				id_server,
				id_server,
			))

			landowners = cursor.fetchall()

			for landowner in landowners:
				owner_id_user = int(landowner[1])
				owner_rent_price = landowner[0]

				user_data = EwUser(id_user=owner_id_user, id_server=id_server)
				user_poi = poi_static.id_to_poi.get(user_data.poi)
				poi = poi_static.id_to_poi.get(user_data.apt_zone)

				if owner_rent_price > user_data.slimecoin:

					if(user_poi.is_apartment and user_data.visiting == ewcfg.location_id_empty):
						user_data.poi = user_data.apt_zone #toss out player
						user_data.persist()
						server = ewcfg.server_list[user_data.id_server]
						member_object = server.get_member(owner_id_user)

						await ewrolemgr.updateRoles(client = client, member=member_object)
						player = EwPlayer(id_user = owner_id_user)
						response = "{} just got evicted. Point and laugh, everyone.".format(player.display_name)
						await fe_utils.send_message(client, fe_utils.get_channel(server, poi.channel), response)


					user_data = EwUser(id_user=owner_id_user, id_server=id_server)
					user_apt = EwApartment(id_user=owner_id_user, id_server=id_server)
					poi = poi_static.id_to_poi.get(user_data.apt_zone)

					toss_items(id_user=str(user_data.id_user) + 'closet', id_server=user_data.id_server, poi = poi)
					toss_items(id_user=str(user_data.id_user) + 'fridge', id_server=user_data.id_server, poi = poi)
					toss_items(id_user=str(user_data.id_user) + 'decorate', id_server=user_data.id_server, poi = poi)

					user_data.apt_zone = ewcfg.location_id_empty
					user_data.persist()
					user_apt.rent = 0
					user_apt.poi = " "
					user_apt.persist()

					await toss_squatters(user_id=user_data.id_user, server_id=id_server)

				else:
					user_data.change_slimecoin(n=-owner_rent_price, coinsource=ewcfg.coinsource_spending)
					user_data.persist()
	finally:
		cursor.close()
		bknd_core.databaseClose(conn_info)
# how long districts stay locked after capture
capture_lock_s = 48 * 60 * 60  # 2 days
capture_lock_a = 24 * 60 * 60  # 1 day
capture_lock_b = 12 * 60 * 60  # 12 hours
capture_lock_c = 6 * 60 * 60  # 6 hours

# district lock times assigned to property classes
capture_locks = {
    property_class_s: capture_lock_s,
    property_class_a: capture_lock_a,
    property_class_b: capture_lock_b,
    property_class_c: capture_lock_c,
}

# how much slimes is needed to bypass capture times
slimes_toannex_s = 1000000  # 1 mega
slimes_toannex_a = 500000  # 500 k
slimes_toannex_b = 200000  # 200 k
slimes_toannex_c = 100000  # 100 k

# slimes to annex by property class
slimes_toannex = {
    property_class_s: slimes_toannex_s,
    property_class_a: slimes_toannex_a,
    property_class_b: slimes_toannex_b,
    property_class_c: slimes_toannex_c
}


""" Attack control of a district, slimecorp only """


async def sanitize(cmd):
    roomba_loop = 0
    while 1:
        # Get user data, then flag for PVP
        user_data = EwUser(id_user=cmd.message.author.id, id_server=cmd.guild.id)

        market_data = EwMarket(id_server=cmd.guild.id)
        time_current = market_data.clock

        time_now_float = time.time()
        time_now = int(time_now_float)

        user_data.persist()

        # Get shooting player's info

        weapon = None
        weapon_item = None
        sidearm_viable = 0
        user_mutations = user_data.get_mutations()

        # if user_data.sidearm >= 0:
        #	weapon_item = EwItem(id_item=user_data.sidearm)
        #	weapon = static_weapons.weapon_map.get(weapon_item.item_props.get("weapon_type"))
        #	captcha = weapon_item.item_props.get('captcha')
        #	if ewcfg.weapon_class_paint in weapon.classes:
        #		sidearm_viable = 1

        if user_data.weapon >= 0 and sidearm_viable == 0:
            weapon_item = EwItem(id_item=user_data.weapon)
            weapon = static_weapons.weapon_map.get(weapon_item.item_props.get("weapon_type"))
            captcha = weapon_item.item_props.get('captcha')

        if weapon_item is not None and roomba_loop == 0:
            if weapon_item.item_props.get("weapon_type") == 'roomba':
                if weapon_item.item_props.get("roomba") == user_data.poi:
                    weapon_item.item_props['roomba'] = ""
                    weapon_item.persist()
                    response = "You pick the roomba back up and have it stop cleaning up the floor."
                    return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))
                else:
                    weapon_item.item_props['roomba'] = user_data.poi
                    weapon_item.persist()

        response = canCap(cmd, "sanitize", roomba_loop)
        if response == "":
            if user_data.slimelevel <= 0:
                user_data.slimelevel = 1
                user_data.persist()

            # Get district data
            poi = poi_static.id_to_poi.get(user_data.poi)
            district_data = EwDistrict(id_server=cmd.guild.id, district=poi.id_poi)

            gangsters_in_district = district_data.get_players_in_district(min_slimes=ewcfg.min_slime_to_cap, life_states=[ewcfg.life_state_enlisted], ignore_offline=True)

            miss = False
            crit = False

            bystander_damage = 0
            hit_chance_mod = 0
            crit_mod = 0
            dmg_mod = 0
            # sap_damage = 0
            # sap_ignored = 0

            weapon.fn_effect = static_weapons.weapon_type_convert.get(weapon.id_weapon)

            shooter_status_mods = cmbt_utils.get_shooter_status_mods(user_data, None, None)

            hit_chance_mod += round(shooter_status_mods['hit_chance'], 2)
            crit_mod += round(shooter_status_mods['crit'], 2)
            dmg_mod += round(shooter_status_mods['dmg'], 2)

            slimes_spent = int(ewutils.slime_bylevel(user_data.slimelevel) / 300)
            slimes_damage = int((50000 + slimes_spent * 10) * (100 + (user_data.weaponskill * 5)) / 100.0)
            slimes_spent = round(slimes_spent * .1125)
            statuses = user_data.getStatusEffects()

            if weapon is None:
                slimes_damage /= 2  # penalty for not using a weapon, otherwise fists would be on par with other weapons

            slimes_damage += int(slimes_damage * dmg_mod)
            # user_data.hunger += ewcfg.hunger_pershot * ewutils.hunger_cost_mod(user_data.slimelevel)

            if weapon != None and weapon.fn_effect != None:
                # Build effect container
                ctn = EwEffectContainer(
                    miss=miss,
                    crit=crit,
                    slimes_damage=slimes_damage,
                    slimes_spent=slimes_spent,
                    user_data=user_data,
                    weapon_item=weapon_item,
                    shootee_data=None,
                    time_now=time_now,
                    bystander_damage=bystander_damage,
                    hit_chance_mod=hit_chance_mod,
                    crit_mod=crit_mod,
                    market_data=market_data,
                    # sap_damage=sap_damage,
                    # sap_ignored=sap_ignored,
                )

                # Make adjustments

                weapon.fn_effect(ctn)

                # Apply effects for non-reference values
                resp_cont = EwResponseContainer(id_server=cmd.guild.id)
                miss = ctn.miss
                crit = ctn.crit
                slimes_damage = ctn.slimes_damage
                slimes_spent = ctn.slimes_spent
                # sap_damage = ctn.sap_damage

                if miss is True and random.randint(0, 1) == 0:
                    miss = False

                if (slimes_spent > user_data.slimes):
                    # Not enough slime to shoot.
                    response = "You don't have enough slime to sanitize. ({:,}/{:,})".format(user_data.slimes, slimes_spent)
                    return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

                # if district_data.controlling_faction == "" and district_data.capture_points == 0:
                #	response = "There's no graffiti to clean up here."
                #	return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

                weapon_item.item_props['time_lastattack'] = time_now_float
                weapon_item.persist()
                user_data.change_slimes(n=(-user_data.slimes if slimes_spent >= user_data.slimes else -slimes_spent), source=ewcfg.source_spending)
                user_data.persist()

                # Remove a bullet from the weapon
                if ewcfg.weapon_class_ammo in weapon.classes:
                    weapon_item.item_props['ammo'] = int(weapon_item.item_props.get("ammo")) - 1

                if miss:
                    slimes_damage = 0

                    weapon_item.item_props["consecutive_hits"] = 0
                    crit = False
                weapon_item.persist()
                # Remove !revive invulnerability.
                user_data.time_lastrevive = 0
                market_data = EwMarket(id_server=cmd.guild.id)
                # apply attacker damage mods
                slimes_damage *= cmbt_utils.damage_mod_attack(
                    user_data=user_data,
                    user_mutations=user_mutations,
                    market_data=market_data,
                    district_data=district_data
                )
                if weapon.id_weapon == ewcfg.weapon_id_watercolors:
                    if not miss:
                        slimes_damage = ewcfg.min_garotte

                elif weapon.id_weapon == ewcfg.weapon_id_thinnerbomb:
                    if user_data.faction == district_data.controlling_faction:
                        slimes_damage = round(slimes_damage * .2)
                    else:
                        slimes_damage *= 3

                if ewcfg.mutation_id_patriot in user_mutations:
                    slimes_damage *= 1.25
                if len(gangsters_in_district) == 1 and ewcfg.mutation_id_lonewolf in user_mutations:
                    slimes_damage *= 1.25

                if 3 <= time_current <= 10:
                    slimes_damage *= (4 / 3)

                credits_added = int(abs(slimes_damage)) * 25

                # if (user_data.faction != district_data.controlling_faction and (user_data.faction is None or user_data.faction == '')) and district_data.capture_points > ewcfg.limit_influence[district_data.property_class]:
                #	slimes_damage = round(slimes_damage / 5)
                #	pass
                if weapon != None:
                    if miss:
                        response = weapon.tool_props[0].get('miss_spray')
                    else:
                        response = "Your sanitizer-filled {} washes away the filth from the city streets.".format(weapon.str_name)
                        response += " You removed {:,} existing influence from gangsters.".format(int(abs(slimes_damage)))

                        if district_data.cap_side == "slimecorp" or district_data.cap_side == "":
                            response = "Your paint-filled {} covers the city in Slimecorp propaganda.".format(weapon.str_name)
                            response += " You added {:,} existing influence for Slimecorp.".format(round(int(abs(slimes_damage))))

                        if (user_data.faction != district_data.cap_side and district_data.cap_side != "") and (user_data.faction is not None or user_data.faction != ''):
                            slimes_damage = round(slimes_damage * -.8)
                        # district_data.change_capture_points()

                        district_data.change_capture_points(progress=slimes_damage, actor=user_data.faction)

                        if crit and weapon.id_weapon == ewcfg.weapon_id_watercolors: district_data.change_capture_points(progress=-district_data.capture_points, actor=user_data.faction)

                        district_data.persist()

                        district_data = EwDistrict(district=district_data.name, id_server=district_data.id_server)
                        # district_data.capture_points += slimes_damage
                        # if district_data.capture_points < 0:
                        #	district_data.controlling_faction = user_data.faction
                        #	district_data.capture_points *= -1
                        # district_data.persist()
                        # response = weapon.str_damage.format(
                        #	name_player=cmd.message.author.display_name,
                        #	name_target=enemy_data.display_name,
                        #	hitzone=randombodypart,
                        #	strikes=strikes
                        # )
                        if (district_data.cap_side == "slimecorp" or district_data.cap_side == '') == "" and crit:
                            response += " You score a critical hit adding {:,} additional influence!".format(round(abs(slimes_damage)))
                        elif crit:
                            response += " You score a critical hit, removing {:,} additional influence!".format(abs(slimes_damage))

                        response += " {:,} salary credits have been added to your profile.".format(credits_added)

                        user_data.persist()

                    # response += " {}".format(weapon.str_crit.format(
                    #	name_player=cmd.message.author.display_name,
                    #	name_target=enemy_data.display_name,
                    #	hitzone=randombodypart,
                    # ))

                    if ewcfg.weapon_class_ammo in weapon.classes and weapon_item.item_props.get("ammo") == 0:
                        response += "\n" + weapon.str_reload_warning.format(name_player=cmd.message.author.display_name)

                    if (ewcfg.weapon_class_captcha in weapon.classes) and roomba_loop == 0:
                        if weapon.id_weapon != ewcfg.weapon_id_paintgun:
                            new_captcha_low = ewutils.generate_captcha(length=weapon.captcha_length)
                            new_captcha = ewutils.text_to_regional_indicator(new_captcha_low)
                            # new_loc = new_loc.replace(new_captcha_low, new_captcha)
                            response += "\nNew captcha is {}.".format(new_captcha)
                            weapon_item.item_props['captcha'] = new_captcha_low
                        # new_captcha = ewutils.generate_captcha(length = weapon.captcha_length)
                        else:
                            riflearray = ewcfg.riflecap
                            direction = str(random.choice(riflearray))
                            weapon_item.item_props['captcha'] = direction
                            new_captcha_gun = ewutils.text_to_regional_indicator(direction)
                            response += "\nNext target is {}.".format(new_captcha_gun)
                        weapon_item.persist()

            else:
                if miss:
                    response = "Your sanitizer completely misses any graffiti..."
                else:
                    response = "Nice community service effort! You clean {damage} influence off the streets!".format(
                        damage=abs(slimes_damage)
                    )
        else:
            if user_data.weapon >= 0:
                weapon_item = EwItem(id_item=user_data.weapon)
                weapon_item.item_props['roomba'] = ""
                weapon_item.persist()
            return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

        user_data = EwUser(member=cmd.message.author)
        if user_data.weapon >= 0:
            weapon_item = EwItem(id_item=user_data.weapon)
            if weapon_item.item_props.get('roomba') == user_data.poi:
                await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))
                await asyncio.sleep(7)
                roomba_loop = 1
            else:
                return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))
        else:
            return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))
# Pay out salaries. SlimeCoin can be taken away or given depending on if the user has positive or negative credits.
async def pay_salary(id_server = None):
    ewutils.logMsg('Paying salary...')

    try:
        conn_info = bknd_core.databaseConnect()
        conn = conn_info.get('conn')
        cursor = conn.cursor()
        client = ewutils.get_client()
        if id_server != None:
            # get all players with apartments. If a player is evicted, thir rent is 0, so this will not affect any bystanders.
            cursor.execute("SELECT id_user FROM users WHERE salary_credits != 0 AND id_server = {}".format(id_server))

            security_officers = cursor.fetchall()

            for officer in security_officers:
                officer_id_user = int(officer[0])

                user_data = EwUser(id_user=officer_id_user, id_server=id_server)
                credits = user_data.salary_credits

                # Prevent the user from obtaining negative slimecoin
                if credits < 0 and user_data.slimecoin < (-1 * credits):
                    user_data.change_slimecoin(n=-user_data.slimecoin, coinsource=ewcfg.coinsource_salary)
                else:
                    user_data.change_slimecoin(n=user_data.salary_credits, coinsource=ewcfg.coinsource_salary)

                user_data.persist()
    finally:
        cursor.close()
        bknd_core.databaseClose(conn_info)

async def payday(cmd):
    user_data = EwUser(member=cmd.message.author)
    credits = user_data.salary_credits

    market_data = EwMarket(id_server=cmd.message.author.guild.id)

    if user_data.poi != ewcfg.poi_id_slimecorphq:
        response = "You don't work here."
    elif user_data.faction != ewcfg.faction_slimecorp:
        response = "You don't work here."
    elif market_data.clock < 6 or market_data.clock >= 8:
        response = "The kind lady at the receptionist desk informs you that paychecks can only be collected between 6 and 8 AM."
    elif credits <= 9999:
        response = "You don't have any salary credits that can be exchanged..."
    else:
        user_data.salary_credits = 0

        slime_added = int(credits / 10000)
        user_data.change_slimes(n=slime_added, source=ewcfg.coinsource_salary)

        user_data.persist()

        response = "You cash in all of your salary credits for {:,} slime.".format(slime_added)

    return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))


async def paycheck(cmd):
    user_data = EwUser(member=cmd.message.author)
    credits = user_data.salary_credits

    if credits == 0:
        response = "You don't have any salary credits..."
    else:
        response = "You have {:,} salary credits.".format(credits)

        if credits > 10000:
            response += " They can be exchanged for {:,} slime with !payday at SlimeCorp HQ.".format(int(credits / 10000))

    return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))
async def clockin(cmd):
    user_data = EwUser(member=cmd.message.author)
    # poi = poi_static.id_to_poi.get(user_data.poi)
    poi_dest = poi_static.id_to_poi.get(ewcfg.poi_id_thebreakroom)

    if ewutils.channel_name_is_poi(cmd.message.channel.name) == False:
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, "You must {} in a zone's channel.".format(cmd.tokens[0])))

    elif ewutils.active_restrictions.get(user_data.id_user) != None and ewutils.active_restrictions.get(user_data.id_user) > 0:
        response = "You can't do that right now."
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

    elif user_data.poi != ewcfg.poi_id_slimecorphq:
        response = "You don't work here."
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

    elif user_data.faction != ewcfg.faction_slimecorp and user_data.life_state != ewcfg.life_state_executive:
        response = "Security guards block your path. It seems the only way through is to assimilate into their ranks and !enlist slimecorp."
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

    else:
        # global move_counter

        move_utils.move_counter += 1
        move_current = ewutils.moves_active[cmd.message.author.id] = move_utils.move_counter
        await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, "You start walking towards the breakroom."))
        await asyncio.sleep(20)

        if move_current == ewutils.moves_active[cmd.message.author.id]:
            user_data = EwUser(member=cmd.message.author)
            user_data.poi = poi_dest.id_poi
            user_data.persist()
            await ewrolemgr.updateRoles(client=cmd.client, member=cmd.message.author)
            response = "Welcome to the breakroom. It's safer here."

            client = ewutils.get_client()
            server = client.get_guild(user_data.id_server)

            await fe_utils.send_message(cmd.client, fe_utils.get_channel(server, poi_dest.channel), fe_utils.formatMessage(cmd.message.author, response))

async def clockout(cmd):
    user_data = EwUser(member=cmd.message.author)
    # poi = poi_static.id_to_poi.get(user_data.poi)
    poi_dest = poi_static.id_to_poi.get(ewcfg.poi_id_slimecorphq)

    if ewutils.channel_name_is_poi(cmd.message.channel.name) == False:
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, "You must {} in a zone's channel.".format(cmd.tokens[0])))

    elif ewutils.active_restrictions.get(user_data.id_user) != None and ewutils.active_restrictions.get(user_data.id_user) > 0:
        response = "You can't do that right now."
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

    elif user_data.poi != ewcfg.poi_id_thebreakroom:
        response = "You don't work here."
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

    else:
        # global move_counter

        move_utils.move_counter += 1
        move_current = ewutils.moves_active[cmd.message.author.id] = move_utils.move_counter
        await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, "You start walking towards the lobby of SlimeCorp HQ."))
        await asyncio.sleep(20)

        if move_current == ewutils.moves_active[cmd.message.author.id]:
            user_data = EwUser(member=cmd.message.author)
            user_data.poi = poi_dest.id_poi
            user_data.persist()
            await ewrolemgr.updateRoles(client=cmd.client, member=cmd.message.author)
            response = "Well, time to get to work."

            client = ewutils.get_client()
            server = client.get_guild(user_data.id_server)

            await fe_utils.send_message(cmd.client, fe_utils.get_channel(server, poi_dest.channel), fe_utils.formatMessage(cmd.message.author, response))

async def get_attire(cmd):
    user_data = EwUser(member=cmd.message.author)
    status = user_data.getStatusEffects()
    if user_data.poi != ewcfg.poi_id_thebreakroom:
        response = "Are you a Slimecorp Security Force official, planted firmly in their lavish breakroom? No? Then you're not getting shit."
    elif ewcfg.status_kevlarattire_id in status:
        response = "You're already armed, though. This stuff's too expensive so the company's not gonna let you double dip."
    elif user_data.life_state != ewcfg.life_state_enlisted:
        response = "You're not committed enough to wear this attire. You're a slob. How did you even get in here?"
    else:
        response = "You suit up in top-of-the-line Kevlar attire. Sleek. Professional. Bulletproof."
        await assign_status_effect(status_name='kevlarattire', user_id=cmd.message.author.id, server_id=cmd.guild.id, cmd=cmd)
    return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

""" Lets shamblers start an event in DMs to get brains """


async def gvs_searchforbrainz(cmd):
    user_data = EwUser(member=cmd.message.author)

    if user_data.life_state != ewcfg.life_state_shambler:
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, "You're not based enough to do that."))

    if user_data.poi != ewcfg.poi_id_slimesea:
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, "You have to {} in the Slime Sea.".format(ewcfg.cmd_gvs_searchforbrainz)))

    time_now = int(time.time())

    if user_data.gvs_time_lastshambaquarium + ewcfg.cd_gvs_searchforbrainz >= time_now:
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, "You'll have to rest for a while before searching for brainz again."))

    event_props = {}
    event_props['id_user'] = cmd.message.author.id
    event_props['brains_grabbed'] = 1
    event_props['captcha'] = ewutils.generate_captcha(length=1, user_data=user_data)
    event_props['channel'] = cmd.message.author.id

    # DM user
    response = poi_static.event_type_to_def.get(ewcfg.event_type_shambaquarium).str_event_start.format(ewcfg.cmd_gvs_grabbrainz, ewutils.text_to_regional_indicator(event_props['captcha']))
    try:
        await fe_utils.send_message(cmd.client, cmd.message.author, response)
    except fe_utils.discord.errors.Forbidden:
        response = "You have to allow ENDLESS WAR to DM you to search for brainz!"
        return await fe_utils.send_message(cmd.client, cmd.message.channel, response)

    user_data = EwUser(member=cmd.message.author)

    # check if the user's state hasn't changed just in case
    if user_data.life_state != ewcfg.life_state_shambler:
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, "You're not based enough to do that."))

    if user_data.poi != ewcfg.poi_id_slimesea:
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, "You have to {} in the Slime Sea.".format(ewcfg.cmd_gvs_searchforbrainz)))

    bknd_worldevent.create_world_event(
        id_server=user_data.id_server,
        event_type=ewcfg.event_type_shambaquarium,
        time_activate=time_now,
        time_expir=time_now + 60,  # 1 minute
        event_props=event_props
    )


    user_data.persist()


""" Command for shamblers to get brains in the shambaquarium event """


async def gvs_grabbrainz(cmd):
    if not isinstance(cmd.message.channel, fe_utils.discord.channel.DMChannel):
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, "You have to {} in DMs.".format(ewcfg.cmd_gvs_grabbrainz)))

    user_data = EwUser(id_user=cmd.message.author.id, id_server=cmd.guild.id)

    if user_data.life_state != ewcfg.life_state_shambler:
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, "You're not based enough to do that."))

    if user_data.poi != ewcfg.poi_id_slimesea:
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, "You have to {} in the Slime Sea.".format(ewcfg.cmd_gvs_grabbrainz)))

    # look for a shambaquarium event belonging to this player
    world_events = bknd_worldevent.get_world_events(id_server=cmd.guild.id)
    for id_event in world_events:
        if world_events.get(id_event) == ewcfg.event_type_shambaquarium:
            event_data = EwWorldEvent(id_event=id_event)
            if int(event_data.event_props.get('id_user')) == user_data.id_user:

                captcha = ewutils.flattenTokenListToString(cmd.tokens[1:]).lower()

                if event_data.event_props.get('captcha').lower() == captcha:
                    event_data.event_props['brains_grabbed'] = int(event_data.event_props['brains_grabbed']) + 1
                    captcha_length = int(event_data.event_props['brains_grabbed'])
                    event_data.event_props['captcha'] = ewutils.generate_captcha(length=captcha_length if captcha_length < 8 else 8, user_data=user_data)
                    event_data.persist()

                    user_data.gvs_currency += ewcfg.brainz_per_grab
                    user_data.persist()

                    response = "You grabbed {} brainz! Baaaaaased! New captcha: ".format(ewcfg.brainz_per_grab) + ewutils.text_to_regional_indicator(event_data.event_props['captcha'])
                    return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

                else:
                    event_data.event_props['captcha'] = ewutils.generate_captcha(length=int(event_data.event_props['brains_grabbed']), user_data=user_data)
                    event_data.persist()
                    response = "Missed! That was pretty cringe dude... New captcha: " + ewutils.text_to_regional_indicator(event_data.event_props['captcha'])
                    return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

            # break

    return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, "You have to {} before trying to grab any brainz!".format(ewcfg.cmd_gvs_searchforbrainz)))


""" Lets shamblers enter the slime sea"""


async def gvs_dive(cmd):
    user_data = EwUser(member=cmd.message.author)

    if user_data.life_state != ewcfg.life_state_shambler:
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, "You're not based enough to do that."))

    if user_data.poi != ewcfg.poi_id_nuclear_beach_edge:
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, "You have to {} at the edge of Nuclear Beach.".format(ewcfg.cmd_gvs_dive)))

    await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, "You begin swimming towards the Slime Sea."), delete_after=15)

    await asyncio.sleep(15)

    user_data = EwUser(member=cmd.message.author)
    user_data.poi = ewcfg.poi_id_slimesea
    user_data.persist()

    slimesea = poi_static.id_to_poi.get(ewcfg.poi_id_slimesea)
    sea_channel = fe_utils.get_channel(cmd.guild, slimesea.channel)
    await fe_utils.send_message(cmd.client, sea_channel, fe_utils.formatMessage(cmd.message.author, "You arrive in the Slime Sea."), delete_after=10)

    await ewrolemgr.updateRoles(client=cmd.client, member=cmd.message.author)


""" Lets shamblers exit the slime sea"""


async def gvs_resurface(cmd):
    user_data = EwUser(member=cmd.message.author)

    if user_data.life_state != ewcfg.life_state_shambler:
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, "You're not based enough to do that."))

    if user_data.poi != ewcfg.poi_id_slimesea:
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, "You have to {} at the Slime Sea.".format(ewcfg.cmd_gvs_resurface)))

    await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, "You begin swimming towards the Nuclear Beach."), delete_after=15)

    await asyncio.sleep(15)

    user_data = EwUser(member=cmd.message.author)
    user_data.poi = ewcfg.poi_id_nuclear_beach_edge
    user_data.persist()

    beach = poi_static.id_to_poi.get(ewcfg.poi_id_nuclear_beach_edge)
    beach_channel = fe_utils.get_channel(cmd.guild, beach.channel)
    await fe_utils.send_message(cmd.client, beach_channel, fe_utils.formatMessage(cmd.message.author, "You arrive in the Nuclear Beach."), delete_after=10)

    await ewrolemgr.updateRoles(client=cmd.client, member=cmd.message.author)


""" Sell a potted gaiaslimeoid to Hortisolis """


async def gvs_sell_gaiaslimeoid(cmd):
    user_data = EwUser(member=cmd.message.author)

    if user_data.life_state == ewcfg.life_state_shambler:
        response = "You lack the higher brain functions required to {}.".format(cmd.tokens[0])
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

    # Only at the Atomic Forest
    if user_data.poi != ewcfg.poi_id_og_farms:
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, "You have to be in the Atomic Forest to sell your Gaiaslimeoids."))

    item_search = ewutils.flattenTokenListToString(cmd.tokens[1:])
    item_sought = bknd_item.find_item(item_search=item_search, id_user=cmd.message.author.id, id_server=cmd.guild.id, item_type_filter=ewcfg.it_item)

    if item_sought:
        gaiaslimeoid = EwItem(id_item=item_sought.get('id_item'))

        if gaiaslimeoid.item_props.get('id_item') != ewcfg.item_id_gaiaslimeoid_pot:
            response = "Hortisolis politely refuses that item. He informs you that it is not a potted Gaiaslimeoid."
            return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

        slime_gain = 20000 * int(gaiaslimeoid.item_props.get('size'))

        gaia_type = gaiaslimeoid.item_props.get('gaiaslimeoid')

        response = 'Hortisolis speaks in a boisterous manner:\n"FOR THOUST {} GAIASLIMEOID, I SUBMIT {} SLIME. DO YOU {}, OR WOULD YOU RATHER {}?"'.format(gaia_type, slime_gain, ewcfg.cmd_accept, ewcfg.cmd_refuse)
        await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

        # Wait for an answer
        accepted = False
        try:
            msg = await cmd.client.wait_for('message', timeout=30, check=lambda message: message.author == cmd.message.author and message.content.lower() in [ewcfg.cmd_accept, ewcfg.cmd_refuse])

            if msg != None:
                if msg.content == ewcfg.cmd_accept:
                    accepted = True
        except:
            accepted = False

        gaiaslimeoid = EwItem(id_item=item_sought.get('id_item'))
        # cancel deal if the gaiaslimeoid is no longer in user's inventory
        if gaiaslimeoid.id_owner != str(user_data.id_user):
            accepted = False

        if accepted:
            user_data = EwUser(member=cmd.message.author)
            user_data.change_slimes(slime_gain)
            user_data.persist()

            bknd_item.item_delete(gaiaslimeoid.id_item)

            response = "Hortisolis gives you {} slime for your {} Gaiaslimeoid.".format(slime_gain, gaiaslimeoid.item_props.get('gaiaslimeoid'))

        else:
            response = '"A PITY, PERHAPS YOU WILL FIND SOME USE FOR IT ELSEWHERE. PRITHEE BE CAREFUL!"'

    else:
        response = "Are you sure you have that Gaiaslimeoid?"

    return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))


""" Dig up a gaiaslimeoid """


async def dig(cmd):  # TODO  zen garden functionality

    if cmd.tokens_count < 2:
        response = 'Specify which coordinate you want to dig up.'
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

    user_data = EwUser(member=cmd.message.author)

    if user_data.life_state == ewcfg.life_state_shambler:
        response = "You lack the higher brain functions required to {}.".format(cmd.tokens[0])
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

    weapon_item = EwItem(id_item=user_data.weapon)

    if weapon_item.item_props.get("weapon_type") != ewcfg.weapon_id_shovel:
        response = "You can't dig Gaiaslimeoids without a shovel, dumbass. Buy one from Hortisolis at the Atomic Forest in Ooze Gardens Farms!"
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

    coord = cmd.tokens[1].upper()
    is_garden = False

    # Look for gaiaslimeoid
    gaias = hunt_utils.gvs_get_gaias_from_coord(user_data.poi, coord)

    dig_low_priority = [ewcfg.enemy_type_gaia_rustealeaves]
    dig_mid_priority = []
    dig_high_priority = [ewcfg.enemy_type_gaia_steelbeans]

    # ID of gaiaslimeoid found
    dig_target = None

    for enemy_id in ewcfg.gvs_enemies_gaiaslimeoids:
        if enemy_id not in dig_low_priority and enemy_id not in dig_high_priority:
            dig_mid_priority.append(enemy_id)

    type_to_id_map = {}
    for id in gaias.keys():
        type = gaias[id]
        type_to_id_map[type] = id

    for target in dig_high_priority:
        if target in type_to_id_map.keys():
            dig_target = type_to_id_map[target]

    for target in dig_mid_priority:
        if target in type_to_id_map.keys():
            dig_target = type_to_id_map[target]

    for target in dig_low_priority:
        if target in type_to_id_map.keys():
            dig_target = type_to_id_map[target]

    # is_garden = if it was a garden

    if dig_target is None:
        response = "There are no Gaiaslimeoids here."
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

    if not is_garden:

        enemy = EwEnemy(id_server=user_data.id_server, id_enemy=dig_target)
        bknd_hunt.delete_enemy(enemy)

        if random.random() < 0.8:  # 90% chance to fail
            response = "You dig up a {} Gaiaslimeoid."
            return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

        bknd_item.item_create(
            item_type=ewcfg.it_item,
            id_user=cmd.message.author.id,
            id_server=cmd.guild.id,
            item_props={
                'id_item': ewcfg.item_id_gaiaslimeoid_pot,
                'item_name': "Pot containing a {} Gaiaslimeoid".format(enemy.display_name),
                'item_desc': "It's a pot with a {} foot-tall {} Gaiaslimeoid. You can place it in a zen garden or sell it to Hortisolis.".format("{size}", enemy.display_name),
                'time_lastslimed': int(time.time()),
                'size': 1,
                'gaiaslimeoid': enemy.enemytype
            }
        )

        response = "You dig up a {} Gaiaslimeoid and place it in a pot!".format(enemy.display_name)

    else:
        response = "Placeholder zen garden dig"
    # change owner

    return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))


async def gvs_progress(cmd):
    op_districts = []
    response = ""

    for poi in poi_static.poi_list:
        # if poi.is_district and not poi.id_poi in [ewcfg.poi_id_rowdyroughhouse, ewcfg.poi_id_copkilltown, ewcfg.poi_id_juviesrow, ewcfg.poi_id_oozegardens, ewcfg.poi_id_assaultflatsbeach, ewcfg.poi_id_thevoid]:
        if poi.is_district:
            op_districts.append(poi.id_poi)

    degradation_data = bknd_core.execute_sql_query("SELECT district, degradation FROM districts WHERE district IN {} AND id_server = {}".format(tuple(op_districts), cmd.message.guild.id))

    non_degraded_districts = []
    degraded_districts = []

    for district in degradation_data:
        if district[1] == 0:
            non_degraded_districts.append(district[0])
        elif district[1] == ewcfg.district_max_degradation:
            degraded_districts.append(district[0])

    # non_degraded_districts = set(non_degraded_districts)
    # degraded_districts = set(degraded_districts)

    counter = 0
    response += "\n**Rejuvenated Districts**"
    for non_deg in non_degraded_districts:
        if counter % 5 == 0:
            response += "\n"

        poi = poi_static.id_to_poi.get(non_deg)
        counter += 1

        if counter != len(non_degraded_districts):
            response += "{}, ".format(poi.str_name)
        else:
            response += "and {}.".format(poi.str_name)

    counter = 0
    response += "\n**Shambled Districts**"
    for deg in degraded_districts:
        if counter % 5 == 0:
            response += "\n"

        poi = poi_static.id_to_poi.get(deg)
        counter += 1

        if counter != len(degraded_districts):
            response += "{}, ".format(poi.str_name)
        else:
            response += "and {}.".format(poi.str_name)

    return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))


async def gvs_gaiaslime(cmd):
    user_data = EwUser(member=cmd.message.author)

    district_data = EwDistrict(district=user_data.poi, id_server=user_data.id_server)

    if district_data.gaiaslime > 0:
        response = "This district houses {} gaiaslime.".format(district_data.gaiaslime)
    else:
        response = "There is no gaiaslime to be found here."
    return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))


async def gvs_brainz(cmd):
    user_data = EwUser(member=cmd.message.author)

    response = "You have {} brainz.".format(user_data.gvs_currency)
    return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

"""
    GVS COMMANDS
"""


async def gvs_print_grid(cmd):
    author = cmd.message.author
    user_data = EwUser(member=author)

    grid_map = hunt_utils.gvs_create_gaia_grid_mapping(user_data)

    debug = False
    if debug:
        blue_blank = ':blue_heart:'
        green_lawn = ':green_heart:'
        lime_lawn = ':yellow_heart:'
    else:
        blue_blank = ewcfg.emote_blankregional
        green_lawn = ewcfg.emote_greenlawn
        lime_lawn = ewcfg.emote_limelawn

    emote_set = []
    # print(grid_map)

    green_or_lime = lime_lawn
    for row in ewcfg.gvs_valid_coords_gaia:
        for coord in row:

            if green_or_lime == lime_lawn:
                green_or_lime = green_lawn
            else:
                green_or_lime = lime_lawn

            if coord in grid_map.keys():
                emote = ewcfg.gvs_enemy_emote_map[grid_map[coord]]

                if debug:
                    emote = ewcfg.gvs_enemy_emote_map_debug[grid_map[coord]]

                emote_set.append(emote)
            else:
                emote_set.append(green_or_lime)

    printed_grid_row_0 = "\n{}{}{}{}{}{}{}{}{}{}".format(
        blue_blank,
        ':one:',
        ':two:',
        ':three:',
        ':four:',
        ':five:',
        ':six:',
        ':seven:',
        ':eight:',
        ':nine:'
    )

    printed_grid_row_1 = "\n{}{}{}{}{}{}{}{}{}{}".format(
        ':regional_indicator_a:',
        emote_set[0],
        emote_set[1],
        emote_set[2],
        emote_set[3],
        emote_set[4],
        emote_set[5],
        emote_set[6],
        emote_set[7],
        emote_set[8],
    )

    printed_grid_row_2 = "\n{}{}{}{}{}{}{}{}{}{}".format(
        ':regional_indicator_b:',
        emote_set[9],
        emote_set[10],
        emote_set[11],
        emote_set[12],
        emote_set[13],
        emote_set[14],
        emote_set[15],
        emote_set[16],
        emote_set[17],
    )

    printed_grid_row_3 = "\n{}{}{}{}{}{}{}{}{}{}".format(
        ':regional_indicator_c:',
        emote_set[18],
        emote_set[19],
        emote_set[20],
        emote_set[21],
        emote_set[22],
        emote_set[23],
        emote_set[24],
        emote_set[25],
        emote_set[26],
    )

    printed_grid_row_4 = "\n{}{}{}{}{}{}{}{}{}{}".format(
        ':regional_indicator_d:',
        emote_set[27],
        emote_set[28],
        emote_set[29],
        emote_set[30],
        emote_set[31],
        emote_set[32],
        emote_set[33],
        emote_set[34],
        emote_set[35],
    )

    printed_grid_row_5 = "\n{}{}{}{}{}{}{}{}{}{}".format(
        ':regional_indicator_e:',
        emote_set[36],
        emote_set[37],
        emote_set[38],
        emote_set[39],
        emote_set[40],
        emote_set[41],
        emote_set[42],
        emote_set[43],
        emote_set[44],
    )

    full_grid_response = printed_grid_row_0 + printed_grid_row_1 + printed_grid_row_2 + printed_grid_row_3 + printed_grid_row_4 + printed_grid_row_5
    # print('Grid response length: {}'.format(len(full_grid_response)))

    return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, full_grid_response))


async def gvs_print_lane(cmd):
    author = cmd.message.author
    user_data = EwUser(member=author)

    debug = False

    response = ""
    if cmd.tokens_count != 2:
        response = "Which lane do you want to check? Options are A, B, C, D, or E"
    else:
        chosen_lane = cmd.tokens[1].lower()
        lanes = ['a', 'b', 'c', 'd', 'e']

        if chosen_lane not in lanes:
            response = "That's not a valid lane, bitch."
        else:

            lane_index = lanes.index(chosen_lane)
            row_used = ewcfg.gvs_valid_coords_gaia[lane_index]

            coord_sets = hunt_utils.gvs_create_gaia_lane_mapping(user_data, row_used)

            counter = 0
            for coord_set in coord_sets:
                current_coord = row_used[counter]
                counter += 1

                response += "\n**{}**: (".format(current_coord)
                if len(coord_set) == 0:
                    response += "Empty"
                else:
                    for enemy_id in coord_set:
                        if enemy_id == 'frozen':
                            response += "FROZEN"
                        else:
                            enemy_data = EwEnemy(id_server=user_data.id_server, id_enemy=enemy_id)
                            props = enemy_data.enemy_props

                            if debug:
                                response += ewcfg.gvs_enemy_emote_map_debug[enemy_data.enemytype]
                                if props.get('joybean') == 'true':
                                    response += "-{}".format(ewcfg.gvs_enemy_emote_map_debug[ewcfg.enemy_type_gaia_joybeans])
                                if props.get('metallicap') == 'true':
                                    response += "-{}".format(ewcfg.gvs_enemy_emote_map_debug[ewcfg.enemy_type_gaia_metallicaps])
                                elif props.get('aushuck') == 'true':
                                    response += "-{}".format(ewcfg.gvs_enemy_emote_map_debug[ewcfg.enemy_type_gaia_aushucks])
                            else:
                                response += ewcfg.gvs_enemy_emote_map[enemy_data.enemytype]
                                if props.get('joybean') == 'true':
                                    response += "-{}".format(ewcfg.gvs_enemy_emote_map[ewcfg.enemy_type_gaia_joybeans])
                                if props.get('metallicap') == 'true':
                                    response += "-{}".format(ewcfg.gvs_enemy_emote_map[ewcfg.enemy_type_gaia_metallicaps])
                                elif props.get('aushuck') == 'true':
                                    response += "-{}".format(ewcfg.gvs_enemy_emote_map[ewcfg.enemy_type_gaia_aushucks])

                            response += " "

                response += ") "

    return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))


async def gvs_incubate_gaiaslimeoid(cmd):
    user_data = EwUser(member=cmd.message.author)
    valid_material = False

    if user_data.poi != ewcfg.poi_id_og_farms:
        response = "You lack the proper equipment to create a Gaiaslimeoid. Head to the Atomic Forest in Ooze Gardens Farms!"
    else:
        if cmd.tokens_count < 2:
            material_counter = 0
            material_total = 0
            response = "Please specify the crop material you will use. Options are...\n"
            for material in static_items.seedpacket_ingredient_list:
                material_counter += 1
                material_total += 1
                response += "**{}**".format(material)
                if material_total != len(static_items.seedpacket_ingredient_list):
                    response += ", "

                if material_counter == 5:
                    material_counter = 0
                    response += "\n"
        else:
            material = ewutils.flattenTokenListToString(cmd.tokens[1:])

            for material_id in static_items.seedpacket_ingredient_list:
                if material in material_id or material == material_id:
                    valid_material = True
                    break

            if not valid_material:
                response = "That's not a crop material you can use, bitch."
            else:

                material_item = bknd_item.find_item(item_search=material, id_user=cmd.message.author.id, id_server=cmd.message.guild.id if cmd.message.guild is not None else None, item_type_filter=ewcfg.it_item)
                if material_item == None:
                    response = "You don't have that crop material in your inventory, bitch."
                else:

                    generated_seedpacket_id = static_items.seedpacket_material_map[material_id]
                    item = static_items.item_map.get(generated_seedpacket_id)

                    item_type = ewcfg.it_item
                    if item != None:
                        bknd_item.item_delete(id_item=material_item.get('id_item'))
                        name = item.str_name

                        item_props = itm_utils.gen_item_props(item)

                        generated_item_id = bknd_item.item_create(
                            item_type=item_type,
                            id_user=cmd.message.author.id,
                            id_server=cmd.message.guild.id,
                            item_props=item_props
                        )

                        response = "You insert your crop material into the patent-pending Garden Ganker Homunculifier-9000:tm: and pull down hard on the large metallic lever. After a bunch of bells, whistles, and flashing lights sound off, out pops a {}!".format(name)

                    else:
                        return ewutils.logMsg("ERROR: Could not produce seed packet for material {}.".format(material))

    return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))


async def gvs_fabricate_tombstone(cmd):
    user_data = EwUser(member=cmd.message.author)

    if user_data.poi != ewcfg.poi_id_nuclear_beach_edge:
        response = "You lack the proper equipment to fabricate a Tombstone. Head to Dr. Downpour's Laboratory at the edge of Nuclear Beach!"
    else:
        if cmd.tokens_count < 2:
            tombstone_counter = 0
            tombstone_total = 0
            enemy_counter = 0
            response = "Please specify the tombstone you want to fabricate. Options are...\n"
            for tombstone in static_items.tombstone_enemytype_map.keys():
                tombstone_counter += 1
                tombstone_total += 1
                response += "**{}**".format(tombstone)
                if tombstone_total != len(static_items.tombstone_enemytype_map):
                    response += ", "

                if enemy_counter == 5:
                    enemy_counter = 0
                    response += "\n"
        else:
            tombstone = ewutils.flattenTokenListToString(cmd.tokens[1:])
            if tombstone not in static_items.tombstone_enemytype_map.keys():
                response = "That's not a valid tombstone you can make, bitch."
            else:

                brainz = user_data.gvs_currency
                generated_tombstone_id = tombstone
                item = static_items.item_map.get(generated_tombstone_id)
                if item != None:
                    cost = item.cost
                    name = item.str_name
                    item_type = ewcfg.it_item

                    if cost > brainz:
                        response = "A {} costs {} brainz to fabricate, and you only have {}.".format(name, cost, brainz)
                    else:
                        user_data.gvs_currency -= cost

                        item_props = itm_utils.gen_item_props(item)

                        generated_item_id = bknd_item.item_create(
                            item_type=item_type,
                            id_user=cmd.message.author.id,
                            id_server=cmd.message.guild.id,
                            item_props=item_props
                        )

                        response = "You insert {} of your hard earned brainz into the state of the art Downpour 3D Bio-printer, watching carefully as the squishy pink organs are transformed into a {} before your very eyes! You take it out of the machine and go on your merry way.".format(cost, name)

                        user_data.persist()

                else:
                    return ewutils.logMsg("ERROR: Could not produce tombstone for tombstone ID {}.".format(generated_tombstone_id))

    return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))


async def gvs_join_operation(cmd):
    seedpackets = static_items.seedpacket_ids
    tombstones = static_items.tombstone_ids
    time_now = int(time.time())

    user_data = EwUser(member=cmd.message.author)
    poi = poi_static.id_to_poi.get(user_data.poi)
    district_data = EwDistrict(district=user_data.poi, id_server=user_data.id_server)

    response = ""

    if ewutils.channel_name_is_poi(cmd.message.channel.name) == False:
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, "You must {} in a zone's channel.".format(cmd.tokens[0])))

    if district_data.time_unlock > time_now:

        if int((district_data.time_unlock - time_now) / 60) <= 1:
            time_remaining = district_data.time_unlock - time_now
            time_used = 'seconds'
        else:
            time_remaining = int((district_data.time_unlock - time_now) / 60)
            time_used = 'minutes'

        response = "The area is too scarred from recent battles between the Garden Gankers and the Shamblers. It needs {} more {} to heal before you can start an operation here.".format(time_remaining, time_used)
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

    if not poi.is_district:
        response = "Oi, dumbass! You can't join an operation if you aren't in a district zone, first!"
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

    if user_data.life_state == ewcfg.life_state_juvenile:
        faction = ewcfg.psuedo_faction_gankers
    elif user_data.life_state == ewcfg.life_state_shambler:
        faction = ewcfg.psuedo_faction_shamblers
    else:
        response = "Hey idiot, it's called *Gankers Vs. Shamblers!* No gangsters, ghosts, or SlimeCorp shills allowed!"
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

    # if faction == ewcfg.psuedo_faction_gankers and district_data.degradation == 0:
    # 	response = "This place is already fully rejuvenated! You'll have to try somewhere else."
    # 	return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))
    # elif faction == ewcfg.psuedo_faction_shamblers and district_data.degradation == ewcfg.district_max_degradation:
    # 	response = "This place is already fully shambled! You'll have to try somewhere else."
    # 	return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))
    if poi.id_poi in [ewcfg.poi_id_juviesrow, ewcfg.poi_id_rowdyroughhouse, ewcfg.poi_id_copkilltown]:
        response = "This place is too heavily guarded. Trying to pull of an operation here strikes you as downright stupid."
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))
    elif poi.id_poi == ewcfg.poi_id_thevoid:
        response = "Wow, great idea shithead, this sure is prime real estate you're trying to take over here in the middle of fucking nowhere. Try somewhere else."
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))
    elif poi.id_poi in [ewcfg.poi_id_assaultflatsbeach, ewcfg.poi_id_oozegardens]:
        response = "It would be reckless to try and start an operation so close to the base of the {}. You'll have to try somewhere else.".format('Garden Gankers' if poi.id_poi == ewcfg.poi_id_oozegardens else 'Shamblers')
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

    in_operation, op_poi = hunt_utils.gvs_check_if_in_operation(user_data)
    if in_operation:
        if op_poi != user_data.poi:
            response = "You're already in an operation! If you wanna add another {}, you'll have to head to {}, first!".format('seed packet' if faction == ewcfg.psuedo_faction_gankers else 'tombstone', op_poi)
            return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

    if cmd.tokens_count < 2:
        response = "You need to select a {} first, dummy!".format('seed packet' if faction == ewcfg.psuedo_faction_gankers else 'tombstone')
    else:
        selected_item = ewutils.flattenTokenListToString(cmd.tokens[1:])

        # if faction == ewcfg.psuedo_faction_gankers:
        # 	choices = seedpackets
        # else:
        # 	choices = tombstones
        #
        # found_choice = False
        # for choice in choices:
        # 	if selected_item in choice:
        # 		selected_item = choice
        # 		found_choice = True
        # 		break
        # 	else:
        # 		response = "That's not a valid {} you can select, bitch.".format('seed packet' if faction == ewcfg.psuedo_faction_gankers else 'tombstone')
        #
        # if not found_choice:
        # 	return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

        item_sought = bknd_item.find_item(item_search=selected_item, id_user=user_data.id_user, id_server=user_data.id_server, item_type_filter=ewcfg.it_item)

        if item_sought != None:
            item = EwItem(id_item=item_sought.get('id_item'))
            item_props = item.item_props

            id_item = item_props.get('id_item')
            if id_item != None:
                if faction == ewcfg.psuedo_faction_gankers and id_item not in seedpackets:
                    response = "That's not a valid seed packet you can select, bitch."
                    return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))
                elif faction == ewcfg.psuedo_faction_shamblers and id_item not in tombstones:
                    response = "That's not a valid tombstone you can select, bitch."
                    return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))
            else:
                response = "That's not a valid {} you can select, bitch.".format('seed packet' if faction == ewcfg.psuedo_faction_gankers else 'tombstone')
                return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

            if item_props.get('brainpower') != None:
                brainpower = int(item_props.get('brainpower'))  # Only for tombstones
            else:
                brainpower = 0

            enemytype = item_props.get('enemytype')

            is_duplicate = hunt_utils.gvs_check_operation_duplicate(user_data.id_user, user_data.poi, enemytype, faction)

            if is_duplicate:
                if faction == ewcfg.psuedo_faction_gankers:
                    response = "What the hell are you doing? You've already selected that seed packet!"
                else:
                    response = "Someone else already put down that tombstone."
                return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

            if faction == ewcfg.psuedo_faction_shamblers:
                if district_data.horde_cooldown > time_now:
                    response = "You gotta wait another {} seconds before you can add another tombstone. Your zombie bones ain't what they used to be...".format(district_data.horde_cooldown - time_now)
                    return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))
                else:
                    district_data.horde_cooldown = time_now + brainpower
                    district_data.persist()

            limit_reached, current_limit = hunt_utils.gvs_check_operation_limit(user_data.id_user, user_data.poi, enemytype, faction)

            if limit_reached:
                if faction == ewcfg.psuedo_faction_gankers:
                    response = "You can't select more than 6 seed packets at a time!"
                else:
                    response = "There's not enough room for your tombstone! **(Current Tombstone Limit: {})**".format(current_limit)
                return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

            # await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, "Are you sure? **!accept** or **!refuse**."))

            # # Wait for an answer
            # accepted = False
            # try:
            # 	message = await cmd.client.wait_for_message(timeout=10, author=cmd.message.author, check=ewutils.check_accept_or_refuse)
            #
            # 	if message != None:
            # 		if message.content.lower() == "!accept":
            # 			accepted = True
            # 		if message.content.lower() == "!refuse":
            # 			accepted = False
            # except:
            # 	accepted = False
            accepted = True

            if accepted:

                # Lock juveniles into the district for garden ops
                if faction == ewcfg.psuedo_faction_gankers:
                    ewutils.moves_active[user_data.id_user] = 0
                    ewutils.active_restrictions[user_data.id_user] = 4

                # If there are no player-generated operations, then the bot will simply spawn in ones automatically.
                enemyfaction = ewcfg.psuedo_faction_gankers if faction == ewcfg.psuedo_faction_shamblers else ewcfg.psuedo_faction_shamblers
                opposing_ops = bknd_core.execute_sql_query("SELECT enemytype FROM gvs_ops_choices WHERE district = '{}' AND faction = '{}'".format(user_data.poi, enemyfaction))
                if len(opposing_ops) == 0:
                    hunt_utils.gvs_insert_bot_ops(user_data.id_server, user_data.poi, enemyfaction)
                # print('spawning in bot ops...')

                if in_operation:
                    if faction == ewcfg.psuedo_faction_gankers:
                        response = "You add your {} to the Garden Op".format(item_props.get('item_name'))
                    else:
                        response = "You add your {} to the Graveyard Op".format(item_props.get('item_name'))
                        response += "\n(You and your allies can add another one in {} seconds.)".format(brainpower)
                else:
                    if faction == ewcfg.psuedo_faction_gankers:
                        response = "You ready up for a Garden Op in {} with your {}. *Ready, set, PLANT!*".format(poi.str_name, item_props.get('item_name'))
                        district_data.gaiaslime += 50
                        district_data.persist()
                    else:
                        response = "You place down your {} in {} and get ready for a Graveyard Op. *Ready, set, BRRRRAAAAAIIINNNNZZZZ!*".format(item_props.get('item_name'), poi.str_name)
                        response += "\n(You and your allies can add another one in {} seconds.)".format(brainpower)

                # durability = int(item_props.get('durability'))

                if faction == ewcfg.psuedo_faction_shamblers:
                    shambler_stock = int(item_props.get('stock'))
                else:
                    shambler_stock = 0

                # if durability > 1:
                # 	item.item_props['durability'] = durability - 1
                # 	item.persist()
                # 	response += "\n(Your {}'s durability has been lowered)".format(item_props.get('item_name'))
                # else:
                # 	bknd_item.item_delete(item.id_item)
                # 	response += "\n(Your {} has been used up completely)".format(item_props.get('item_name'))

                op_data = EwOperationData(
                    id_user=user_data.id_user,
                    district=user_data.poi,
                    enemytype=enemytype,
                    faction=faction,
                    id_item=item_sought.get('id_item'),
                    shambler_stock=shambler_stock
                )
                op_data.persist()

            else:
                response = "Well, perhaps some other time, then."

        else:
            response = "Are you sure you have that {}? Try using **!inv**".format('seed packet' if faction == ewcfg.psuedo_faction_gankers else 'tombstone')

    return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))


async def gvs_leave_operation(cmd):
    user_data = EwUser(member=cmd.message.author)

    if user_data.life_state == ewcfg.life_state_juvenile:
        faction = ewcfg.psuedo_faction_gankers
    elif user_data.life_state == ewcfg.life_state_shambler:
        faction = ewcfg.psuedo_faction_shamblers
    else:
        return

    in_operation, op_poi = hunt_utils.gvs_check_if_in_operation(user_data)
    if not in_operation:
        response = "You aren't even *in* an operation."
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

    await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, "Are you sure? **!accept** or **!refuse**."))

    # Wait for an answer
    accepted = False
    try:

        message = await cmd.client.wait_for('message', timeout=30, check=lambda message: message.author == cmd.message.author and message.content.lower() in [ewcfg.cmd_accept, ewcfg.cmd_refuse])

        if message != None:
            if message.content.lower() == "!accept":
                accepted = True
            if message.content.lower() == "!refuse":
                accepted = False
    except:
        accepted = False

    if accepted:
        ewutils.active_restrictions[user_data.id_user] = 0

        items = bknd_core.execute_sql_query("SELECT id_item FROM gvs_ops_choices WHERE id_user = '{}'".format(user_data.id_user))
        bknd_core.execute_sql_query("DELETE FROM gvs_ops_choices WHERE id_user = '{}'".format(user_data.id_user))
        await bknd_hunt.delete_all_enemies(cmd=None, query_suffix="AND owner = '{}' AND poi = '{}'".format(user_data.id_user, user_data.poi), id_server_sent=user_data.id_server)

        response = "You drop out of your {} Op in {}.".format('Garden' if faction == ewcfg.psuedo_faction_gankers else 'Graveyard', op_poi)

        for item in items:
            item_data = EwItem(id_item=item)
            durability = int(item_data.item_props.get('durability'))

            if faction == ewcfg.psuedo_faction_gankers:
                if durability > 1:
                    item_data.item_props['durability'] = durability - 1
                    item_data.persist()
                    response += "\n(Your {}'s durability has been lowered)".format(item_data.item_props.get('item_name'))
                else:
                    bknd_item.item_delete(item)
                    response += "\n(Your {} has been used up completely)".format(item_data.item_props.get('item_name'))

            else:
                # To prevent shamblers from re-stocking operations with tombstones, they are destroyed upon leaving a graveyard op.
                bknd_item.item_delete(item)
                response += "\n(Your {} has been used up completely)".format(item_data.item_props.get('item_name'))

        response += "\nAll your Gaiaslimeoids in {} wilt and die.".format(op_poi) if faction == ewcfg.psuedo_faction_gankers else "All the shamblers belonging to your tombstone in {} fall apart and collapse onto the ground.".format(op_poi)

    else:
        response = "Well, perhaps some other time, then."

    return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))


async def gvs_check_operations(cmd):
    if cmd.tokens_count == 1:
        operations = bknd_core.execute_sql_query("SELECT district, faction FROM gvs_ops_choices GROUP BY district;")

        response = "There are currently no Garden Ops or Graveyard Ops at this time."
        if len(operations) > 0:
            response = ""
            for op in operations:
                response += "\nThere are operations taking place in {}.".format(poi_static.id_to_poi.get(op[0]).str_name)

    elif cmd.tokens_count > 1:
        checked_district = ewutils.flattenTokenListToString(cmd.tokens[1:])
        district = poi_static.id_to_poi.get(checked_district)

        if district == None or not district.is_district:
            response = "That's not a valid district that you can check"
        else:
            operations = bknd_core.execute_sql_query("SELECT enemytype FROM gvs_ops_choices WHERE district = '{}' GROUP BY enemytype".format(district.id_poi))

            if len(operations) > 0:
                gaias = bknd_core.execute_sql_query("SELECT enemytype FROM gvs_ops_choices WHERE district = '{}' AND faction = 'gankers' GROUP BY enemytype".format(district.id_poi))
                shamblers = bknd_core.execute_sql_query("SELECT enemytype FROM gvs_ops_choices WHERE district = '{}' AND faction = 'shamblers' GROUP BY enemytype".format(district.id_poi))

                response = "In {}, the currently selected seed packets and tombstones include...\n".format(district.str_name)
                response += "**GAIASLIMEOIDS**"
                for gaia in gaias:
                    response += "\n{}".format(gaia[0])
                response += "\n**SHAMBLERS**"
                for shambler in shamblers:
                    response += "\n{}".format(shambler[0])

            else:
                response = "There aren't any operations going on in that district."

    return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))


async def gvs_plant_gaiaslimeoid(cmd):
    seedpackets = static_items.seedpacket_ids
    time_now = int(time.time())

    user_data = EwUser(member=cmd.message.author)
    poi = poi_static.id_to_poi.get(user_data.poi)
    district_data = EwDistrict(district=user_data.poi, id_server=user_data.id_server)

    if not user_data.life_state == ewcfg.life_state_juvenile:
        response = "Only Juveniles of pure heart can lay down Gaiaslimeoids on the field."
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

    if ewutils.channel_name_is_poi(cmd.message.channel.name) == False:
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, "You must {} in a zone's channel.".format(cmd.tokens[0])))
    if not poi.is_district:
        response = "You can't plant a Gaiaslimeoid here, dummy!"
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

    in_operation, op_poi = hunt_utils.gvs_check_if_in_operation(user_data)
    if not in_operation:
        response = "You aren't even *in* an operation."
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))
    elif user_data.poi != op_poi:
        response = "You can't plant a Gaiaslimeoid here, dummy! Try heading to {}.".format(poi_static.id_to_poi.get(op_poi).str_name)
        return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

    if cmd.tokens_count < 3:
        response = "You need to select a coordinate and seed packet, dummy!"
    else:
        coord = cmd.tokens[1].upper()
        selected_item = ewutils.flattenTokenListToString(cmd.tokens[2:])
        valid_coord = False

        for row in ewcfg.gvs_valid_coords_gaia:
            if coord in row:
                valid_coord = True
                break

        if not valid_coord:
            response = "That's not a valid coordinate, bitch."
            return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

        # choices = seedpackets
        #
        # found_choice = False
        # for choice in choices:
        # 	if selected_item in choice:
        # 		selected_item = choice
        # 		found_choice = True
        # 		break
        # 	else:
        # 		response = "That's not a valid seed packet you can select, bitch. (Hint: !plant [coord] [seed packet])"
        #
        # if not found_choice or invalid_coord:
        # 	return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

        item_sought = bknd_item.find_item(item_search=selected_item, id_user=cmd.message.author.id, id_server=user_data.id_server, item_type_filter=ewcfg.it_item)
        if item_sought != None:
            item = EwItem(id_item=item_sought.get('id_item'))
            item_props = item.item_props

            id_item = item_props.get('id_item')
            if id_item != None:
                if id_item not in seedpackets:
                    response = "That's not a valid seed packet you can select, bitch."
                    return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))
            else:
                response = "That's not a valid seed packet you can select, bitch."
                return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

            enemytype = item_props.get('enemytype')
            cooldown = int(item_props.get('cooldown'))
            cost = int(item_props.get('cost'))
            time_nextuse = int(item_props.get('time_nextuse'))

            if cost > district_data.gaiaslime:
                response = "There's not enough Gaiaslime to go around! ({}/{})".format(district_data.gaiaslime, cost)
            elif time_nextuse > time_now:
                response = "You need to wait {} seconds before you can plant that Gaiaslimeoid down.".format(time_nextuse - time_now)
            else:
                item.item_props['time_nextuse'] = time_now + cooldown
                item.persist()

                gaias_in_coord = hunt_utils.gvs_get_gaias_from_coord(user_data.poi, coord)

                if len(gaias_in_coord) > 0:
                    for gaia in gaias_in_coord.keys():
                        enemy_data = EwEnemy(id_enemy=gaias_in_coord[gaia])

                        if enemytype == gaia:
                            if gaia in ewcfg.repairable_gaias:
                                enemy_data.slimes = enemy_data.initialslimes
                                district_data.gaiaslime -= cost
                                enemy_data.persist()
                                district_data.persist()

                                response = "The {} in {} was fully repaired!".format(enemy_data.display_name, enemy_data.gvs_coord)
                                return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))
                            else:
                                response = "There's already a {} in that coordinate!".format(enemy_data.display_name)
                                return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))
                        else:
                            if enemy_data.enemy_props.get('joybean') == 'true' and enemytype == ewcfg.enemy_type_gaia_joybeans:
                                response = "A Joybean has already been planted there."
                                return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))
                            elif enemy_data.enemy_props.get('metallicaps') == 'true' and enemytype == ewcfg.enemy_type_gaia_metallicaps:
                                response = "A Metallicap has already been planted there."
                                return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))
                            elif enemy_data.enemy_props.get('aushucks') == 'true' and enemytype == ewcfg.enemy_type_gaia_aushucks:
                                response = "An Aushuck has already been planted there."
                                return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))
                            else:
                                response = "There's already a {} in that coordinate!".format(enemy_data.display_name)
                                return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

                    district_data.gaiaslime -= cost
                    district_data.persist()

                    resp_cont = hunt_utils.spawn_enemy(
                        id_server=user_data.id_server,
                        pre_chosen_type=enemytype,
                        pre_chosen_level=50,
                        pre_chosen_poi=user_data.poi,
                        pre_chosen_identifier='',
                        pre_chosen_faction=ewcfg.psuedo_faction_gankers,
                        pre_chosen_owner=user_data.id_user,
                        pre_chosen_coord=coord,
                        manual_spawn=True,
                    )

                    return await resp_cont.post()

                else:
                    if enemytype == ewcfg.enemy_type_gaia_metallicaps:
                        response = "Metallicaps must be planted on top of attacking Gaiaslimeoids."
                    elif enemytype == ewcfg.enemy_type_gaia_aushucks:
                        response = "Aushucks must first be planted on top of existing Gaiaslimeoids."
                    else:
                        district_data.gaiaslime -= cost
                        district_data.persist()

                        resp_cont = hunt_utils.spawn_enemy(
                            id_server=user_data.id_server,
                            pre_chosen_type=enemytype,
                            pre_chosen_level=50,
                            pre_chosen_poi=user_data.poi,
                            pre_chosen_identifier='',
                            pre_chosen_faction=ewcfg.psuedo_faction_gankers,
                            pre_chosen_owner=user_data.id_user,
                            pre_chosen_coord=coord,
                            manual_spawn=True,
                        )

                        return await resp_cont.post()

        else:
            response = "Are you sure you have that seed packet? Try using **!inv**"

    return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

    # ewcfg.cmd_gvs_searchforbrainz: cmds.gvs_searchforbrainz,
    # ewcfg.cmd_gvs_grabbrainz: cmds.gvs_grabbrainz,
    # ewcfg.cmd_gvs_dive: cmds.gvs_dive,
    # ewcfg.cmd_gvs_resurface: cmds.gvs_resurface,
    # ewcfg.cmd_gvs_sellgaiaslimeoid: cmds.gvs_sell_gaiaslimeoid,
    # ewcfg.cmd_gvs_sellgaiaslimeoid_alt: cmds.gvs_sell_gaiaslimeoid,
    # ewcfg.cmd_gvs_dig: cmds.dig,
    # ewcfg.cmd_gvs_progress: cmds.gvs_progress,
    # ewcfg.cmd_gvs_gaiaslime: cmds.gvs_gaiaslime,
    # ewcfg.cmd_gvs_gaiaslime_alt1: cmds.gvs_gaiaslime,
    # ewcfg.cmd_gvs_brainz: cmds.gvs_brainz,
    # Gankers Vs. Shamblers -- Please make GvS specific cmd/util files on reimplementation
    # Maybe shoulda had its own file
    # ewcfg.cmd_gvs_printgrid: cmds.gvs_print_grid,
    # ewcfg.cmd_gvs_printgrid_alt1: cmds.gvs_print_grid,
    # ewcfg.cmd_gvs_printlane: cmds.gvs_print_lane,
    # ewcfg.cmd_gvs_incubategaiaslimeoid: cmds.gvs_incubate_gaiaslimeoid,
    # ewcfg.cmd_gvs_fabricatetombstone: cmds.gvs_fabricate_tombstone,
    # ewcfg.cmd_gvs_joinoperation: cmds.gvs_join_operation,
    # ewcfg.cmd_gvs_leaveoperation: cmds.gvs_leave_operation,
    # ewcfg.cmd_gvs_checkoperation: cmds.gvs_check_operations,
    # ewcfg.cmd_gvs_plantgaiaslimeoid: cmds.gvs_plant_gaiaslimeoid,


    cmd_gvs_searchforbrainz = cmd_prefix + 'searchforbrainz'
cmd_gvs_grabbrainz = cmd_prefix + 'grabbrainz'
cmd_gvs_dive = cmd_prefix + 'dive'
cmd_gvs_resurface = cmd_prefix + 'resurface'
cmd_gvs_sellgaiaslimeoid = cmd_prefix + 'sellgaiaslimeoid'
cmd_gvs_sellgaiaslimeoid_alt = cmd_prefix + 'sellgaia'
cmd_gvs_dig = cmd_prefix + 'dig'
cmd_gvs_progress = cmd_prefix + 'gvs'
cmd_gvs_gaiaslime = cmd_prefix + 'gaiaslime'
cmd_gvs_gaiaslime_alt1 = cmd_prefix + 'gs'
cmd_gvs_brainz = cmd_prefix + 'brainz'

cmd_gvs_printgrid = cmd_prefix + 'grid'
cmd_gvs_printgrid_alt1 = cmd_prefix + 'lawn'
cmd_gvs_printlane = cmd_prefix + 'lane'
cmd_gvs_incubategaiaslimeoid = cmd_prefix + 'incubategaiaslimeoid'
cmd_gvs_fabricatetombstone = cmd_prefix + 'fabricatetombstone'
cmd_gvs_joinoperation = cmd_prefix + 'joinop'
cmd_gvs_leaveoperation = cmd_prefix + 'leaveop'
cmd_gvs_checkoperation = cmd_prefix + 'checkops'
cmd_gvs_plantgaiaslimeoid = cmd_prefix + 'plant'

    EwGeneralItem(
        id_item='n12corpse',
        context='corpse',
        str_name="N12's Corpse",
        str_desc="The unzucked corpse of N12. At this point she's hardly recognizable.",
        alias=[
            "n12"
        ]
    ),
    EwGeneralItem(
        id_item='n13corpse',
        context='corpse',
        str_name="N13's Corpse",
        str_desc="The unzucked corpse of N13. The bulb head looks so fragile but it's definitely not breaking anytime soon.",
        alias=[
            "n13"
        ]
    ),
        EwGeneralItem(
        id_item='n6corpse',
        context='corpse',
        str_name="N6's Corpse",
        str_desc="The unzucked corpse of N6. Something is preventing her corpse from entering the Sewers.",
        alias=[
            "n6"
        ]
    ),
    EwGeneralItem(
        id_item='n10corpse',
        context='corpse',
        str_name="N10's Corpse",
        str_desc="The unzucked corpse of N10. Something about lugging this body around feels like a mistake.",
        alias=[
            "n10"
        ]
    ),
        EwGeneralItem(
        id_item="filmreel",
        str_name="VHS Tape",
        str_desc="It's a VHS for one of Slimecorp's old training videos.",
        context="reelkey"
    ),


    enemy_type_gaia_poketubers: {
        "slimerange": [100, 100],
        "ai": enemy_ai_gaiaslimeoid,
        "attacktype": enemy_attacktype_gvs_g_explosion,
        "displayname": "Poketuber",
        "raredisplayname": "Joybean Poketuber",
        "aliases": ['tuber'],
        "class": enemy_class_gaiaslimeoid,
        "props": {
            'primed': 'false',
            'primecountdown': 3,
            'setdamage': 500000,
            'piercing': 'true',
            'range': 2
        }
    },
    enemy_type_gaia_pulpgourds: {
        "slimerange": [50000, 50000],
        "ai": enemy_ai_gaiaslimeoid,
        "attacktype": enemy_attacktype_unarmed,
        "displayname": "Pulp Gourd",
        "raredisplayname": "Joybean Pulp Gourd",
        "aliases": ['gourd', 'pulp'],
        "class": enemy_class_gaiaslimeoid,
        "props": {
            'gourdstorage': 0
        }
    },
    enemy_type_gaia_sourpotatoes: {
        "slimerange": [100000, 100000],
        "ai": enemy_ai_gaiaslimeoid,
        "attacktype": enemy_attacktype_gvs_g_chompers,
        "displayname": "Sour Potato",
        "raredisplayname": "Joybean Sour Potato",
        "aliases": ['potato', 'sour'],
        "class": enemy_class_gaiaslimeoid,
        "props": {
            'chewingcountdown': 0,
            'setdamage': 500000,
            'range': 2
        }
    },
    enemy_type_gaia_bloodcabbages: {
        "slimerange": [100000, 100000],
        "ai": enemy_ai_gaiaslimeoid,
        "attacktype": enemy_attacktype_gvs_g_bloodshot,
        "displayname": "Blood Cabbage",
        "raredisplayname": "Joybean Blood Cabbage",
        "aliases": ['blood', 'cabbage'],
        "class": enemy_class_gaiaslimeoid,
        "props": {
            'setdamage': 20000,
            'range': 20,
            'piercing': 'true',
            'pierceamount': 3
        }
    },
    enemy_type_gaia_joybeans: {
        "slimerange": [500000, 500000],
        "ai": enemy_ai_gaiaslimeoid,
        "attacktype": enemy_attacktype_unarmed,
        "displayname": "Joybean",
        "raredisplayname": "Joybean Fusion!!",
        "aliases": ['bean', 'uhoh', 'youfriccinmoron'],
        "class": enemy_class_gaiaslimeoid,
        "props": {
            'noprop': 'noprop'
        }
    },
    enemy_type_gaia_purplekilliflower: {
        "slimerange": [100000, 100000],
        "ai": enemy_ai_gaiaslimeoid,
        "attacktype": enemy_attacktype_gvs_g_vapecloud,
        "displayname": "Purple Killiflower",
        "raredisplayname": "Joybean Purple Killiflower",
        "aliases": ['purple', 'killiflower', 'cauliflower'],
        "class": enemy_class_gaiaslimeoid,
        "props": {
            'range': 12,
            'piercing': 'true',
            'setdamage': '15000',
        }
    },
    enemy_type_gaia_razornuts: {
        "slimerange": [200000, 200000],
        "ai": enemy_ai_gaiaslimeoid,
        "attacktype": enemy_attacktype_unarmed,
        "displayname": "Razornut",
        "raredisplayname": "Joybean Razornut",
        "aliases": ['razor', 'nut'],
        "class": enemy_class_gaiaslimeoid,
        "props": {
            'setdamage': 20000
        }
    },
    enemy_type_gaia_pawpaw: {
        "slimerange": [200000, 200000],
        "ai": enemy_ai_gaiaslimeoid,
        "attacktype": enemy_attacktype_gvs_g_explosion,
        "displayname": "Pawpaw",
        "raredisplayname": "Joybean Pawpaw",
        "aliases": ['paw'],
        "class": enemy_class_gaiaslimeoid,
        "props": {
            'setdamage': 500000,
            'direction': 'ring',
            'splash': 'true'
        }
    },
    enemy_type_gaia_sludgeberries: {
        "slimerange": [100, 100],
        "ai": enemy_ai_gaiaslimeoid,
        "attacktype": enemy_attacktype_unarmed,
        "displayname": "Sludgeberries",
        "raredisplayname": "Joybean Sludgeberries",
        "aliases": ['berries', 'sludge'],
        "class": enemy_class_gaiaslimeoid,
        "props": {
            'noprop': 'noprop'
        }
    },
    enemy_type_gaia_suganmanuts: {
        "slimerange": [400000, 400000],
        "ai": enemy_ai_gaiaslimeoid,
        "attacktype": enemy_attacktype_unarmed,  # changes to gvs_g_nuts upon the use of a joybean
        "displayname": "Suganmanut",
        "raredisplayname": "Joybean Suganmanut",
        "aliases": ['cashew', 'nuts'],
        "class": enemy_class_gaiaslimeoid,
        "props": {
            'setdamage': 20000
        }
    },
    enemy_type_gaia_pinkrowddishes: {
        "slimerange": [100000, 100000],
        "ai": enemy_ai_gaiaslimeoid,
        "attacktype": enemy_attacktype_gvs_g_fists,
        "displayname": "Pink Rowddish",
        "raredisplayname": "Joybean Pink Rowddish",
        "aliases": ['rowddish', 'raddish'],
        "class": enemy_class_gaiaslimeoid,
        "props": {
            'range': 3,
            'direction': 'frontandback',
            'piercing': 'true',
            'setdamage': 50000
        }
    },
    enemy_type_gaia_dankwheat: {
        "slimerange": [50000, 50000],
        "ai": enemy_ai_gaiaslimeoid,
        "attacktype": enemy_attacktype_gvs_g_hotbox,
        "displayname": "Dankwheat",
        "raredisplayname": "Joybean Dankwheat",
        "aliases": ['weed', 'digiweed', 'digibro', 'wheat'],
        "class": enemy_class_gaiaslimeoid,
        "props": {
            'setdamage': 10000,
            'direction': 'ring',
            'piercing': 'true',
        }
    },
    enemy_type_gaia_brightshade: {
        "slimerange": [50000, 50000],
        "ai": enemy_ai_gaiaslimeoid,
        "attacktype": enemy_attacktype_unarmed,
        "displayname": "Brightshade",
        "raredisplayname": "Double Brightshade",
        "aliases": ['bright', 'shade'],
        "class": enemy_class_gaiaslimeoid,
        "props": {
            'gaiaslimecountdown': 2
        }
    },
    enemy_type_gaia_blacklimes: {
        "slimerange": [200000, 200000],
        "ai": enemy_ai_gaiaslimeoid,
        "attacktype": enemy_attacktype_unarmed,
        "displayname": "Black Lime",
        "raredisplayname": "Joybean Black Lime",
        "aliases": ['lime', 'black'],
        "class": enemy_class_gaiaslimeoid,
        "props": {
            'noprop': 'noprop'
        }
    },
    enemy_type_gaia_phosphorpoppies: {
        "slimerange": [100000, 100000],
        "ai": enemy_ai_gaiaslimeoid,
        "attacktype": enemy_attacktype_gvs_g_brainwaves,
        "displayname": "Phosphorpoppy",
        "raredisplayname": "Joybean Phosphorpoppy",
        "aliases": ['phosphor', 'poppy'],
        "class": enemy_class_gaiaslimeoid,
        "props": {
            'setdamage': 10000,
            'piercing': 'true',
            'pierceamount': 3
        }
    },
    enemy_type_gaia_direapples: {
        "slimerange": [100000, 100000],
        "ai": enemy_ai_gaiaslimeoid,
        "attacktype": enemy_attacktype_gvs_g_seeds,
        "displayname": "Dire Apple",
        "raredisplayname": "Joybean Dire Apple",
        "aliases": ['apple', 'dire'],
        "class": enemy_class_gaiaslimeoid,
        "props": {
            'setdamage': 35000,
            'splash': 'false'
            # 'singletilepierce': 'true', JOYBEAN
            # 'pierceamount': 3
        }
    },
    enemy_type_gaia_rustealeaves: {
        "slimerange": [200000, 200000],
        "ai": enemy_ai_gaiaslimeoid,
        "attacktype": enemy_attacktype_gvs_g_blades,
        "displayname": "Rustea Leaves",
        "raredisplayname": "Joybean Rustea Leaves",
        "aliases": ['leaves', 'tea'],
        "class": enemy_class_gaiaslimeoid,
        "props": {
            'range': 1,
            'direction': 'frontandback',
            'setdamage': 30000
        }
    },
    enemy_type_gaia_metallicaps: {
        "slimerange": [500000, 500000],
        "ai": enemy_ai_gaiaslimeoid,
        "attacktype": enemy_attacktype_unarmed,
        "displayname": "Metallicaps",
        "raredisplayname": "NULL",
        "aliases": ['mushrooms', 'shrooms', 'shroomz', 'mushroom'],
        "class": enemy_class_gaiaslimeoid,
        "props": {
            # 'setdamage': 30000
            'noprop': 'noprop'
        }
    },
    enemy_type_gaia_steelbeans: {
        "slimerange": [200000, 200000],
        "ai": enemy_ai_gaiaslimeoid,
        "attacktype": enemy_attacktype_unarmed,
        "displayname": "Steel Beans",
        "raredisplayname": "NULL",
        "aliases": ['911', 'steel', 'beans'],
        "class": enemy_class_gaiaslimeoid,
        "props": {
            'noprop': 'noprop'
        }
    },
    enemy_type_gaia_aushucks: {
        "slimerange": [500000, 500000],
        "ai": enemy_ai_gaiaslimeoid,
        "attacktype": enemy_attacktype_unarmed,
        "displayname": "Aushucks",
        "raredisplayname": "NULL",
        "aliases": ['gold', 'shucks', 'corn'],
        "class": enemy_class_gaiaslimeoid,
        "props": {
            # 'gaiaslimecountdown': 4
            'noprop': 'noprop'
        }
    },
    enemy_type_defaultshambler: {
        "slimerange": [125000, 125000],
        "ai": enemy_ai_shambler,
        "attacktype": enemy_attacktype_gvs_s_teeth,
        "displayname": "Default Shambler",
        "raredisplayname": "NULL",
        "aliases": ['zombie'],
        "class": enemy_class_shambler,
        "props": {
            'setdamage': 30000
        }
    },
    enemy_type_bucketshambler: {
        "slimerange": [175000, 175000],
        "ai": enemy_ai_shambler,
        "attacktype": enemy_attacktype_gvs_s_teeth,
        "displayname": "KFC Bucket Shambler",
        "raredisplayname": "NULL",
        "aliases": ['kfc', 'bucket'],
        "class": enemy_class_shambler,
        "props": {
            'setdamage': 30000
        }
    },
    enemy_type_juveolanternshambler: {
        "slimerange": [250000, 250000],
        "ai": enemy_ai_shambler,
        "attacktype": enemy_attacktype_gvs_s_teeth,
        "displayname": "Juve-O'-Lantern Shambler",
        "raredisplayname": "NULL",
        "aliases": ['juveolantern', 'jackolantern'],
        "class": enemy_class_shambler,
        "props": {
            'setdamage': 30000
        }
    },
    enemy_type_flagshambler: {
        "slimerange": [125000, 125000],
        "ai": enemy_ai_shambler,
        "attacktype": enemy_attacktype_gvs_s_teeth,
        "displayname": "Flag Shambler",
        "raredisplayname": "NULL",
        "aliases": ['flag'],
        "class": enemy_class_shambler,
        "props": {
            'setdamage': 30000
        }
    },
    enemy_type_shambonidriver: {
        "slimerange": [175000, 175000],
        "ai": enemy_ai_shambler,
        "attacktype": enemy_attacktype_gvs_s_shamboni,
        "displayname": "Shamboni Driver",
        "raredisplayname": "NULL",
        "aliases": ['zomboni', 'driver', 'zamboni'],
        "class": enemy_class_shambler,
        "props": {
            'setdamage': 250000
        }
    },
    enemy_type_mammoshambler: {
        "slimerange": [250000, 250000],
        "ai": enemy_ai_shambler,
        "attacktype": enemy_attacktype_gvs_s_tusks,
        "displayname": "Mammoshambler",
        "raredisplayname": "NULL",
        "aliases": ['mammoth', 'brunswick'],
        "class": enemy_class_shambler,
        "props": {
            'setdamage': 100000,
            'turncountdown': 2
        }
    },
    enemy_type_gigashambler: {
        "slimerange": [500000, 500000],
        "ai": enemy_ai_shambler,
        "attacktype": enemy_attacktype_gvs_s_cudgel,
        "displayname": "Gigashambler",
        "raredisplayname": "NULL",
        "aliases": ['giga', 'gigachad'],
        "class": enemy_class_shambler,
        "props": {
            'setdamage': 200000,
            'turncountdown': 2,
            'microspawned': 'false'
        }
    },
    enemy_type_microshambler: {
        "slimerange": [60000, 60000],
        "ai": enemy_ai_shambler,
        "attacktype": enemy_attacktype_gvs_s_teeth,
        "displayname": "Microshambler",
        "raredisplayname": "NULL",
        "aliases": ['micro'],
        "class": enemy_class_shambler,
        "props": {
            'setdamage': 30000
        }
    },
    enemy_type_shamblersaurusrex: {
        "slimerange": [250000, 250000],
        "ai": enemy_ai_shambler,
        "attacktype": enemy_attacktype_gvs_s_fangs,
        "displayname": "Shamblersaurus Rex",
        "raredisplayname": "NULL",
        "aliases": ['rex', 'trex', 't-rex', 'shamblersaurus'],
        "class": enemy_class_shambler,
        "props": {
            'setdamage': 75000,
            'roarused': False,
        }
    },
    enemy_type_shamblerdactyl: {
        "slimerange": [100000, 100000],
        "ai": enemy_ai_shambler,
        "attacktype": enemy_attacktype_gvs_s_talons,
        "displayname": "Shamblerdactyl",
        "raredisplayname": "NULL",
        "aliases": ['bird', 'dactyl'],
        "class": enemy_class_shambler,
        "props": {
            'setdamage': 2000000,
            'grabcountdown': 3
        }
    },
    enemy_type_dinoshambler: {
        "slimerange": [150000, 150000],
        "ai": enemy_ai_shambler,
        "attacktype": enemy_attacktype_gvs_s_fangs,
        "displayname": "Dinoshambler",
        "raredisplayname": "NULL",
        "aliases": ['dinosaur', 'dino'],
        "class": enemy_class_shambler,
        "props": {
            'setdamage': 35000,
            'jumping': 'true'
        }
    },
    enemy_type_ufoshambler: {
        "slimerange": [150000, 150000],
        "ai": enemy_ai_shambler,
        "attacktype": enemy_attacktype_gvs_s_grenadecannon,
        "displayname": "Unnerving Fighting Shambler",
        "raredisplayname": "NULL",
        "aliases": ['ufo'],
        "class": enemy_class_shambler,
        "props": {
            'setdamage': 40000,
            'turncountdown': 2,
            'range': 18
        }
    },
    enemy_type_brawldenboomer: {
        "slimerange": [100000, 100000],
        "ai": enemy_ai_shambler,
        "attacktype": enemy_attacktype_gvs_s_teeth,
        "displayname": "The Brawlden Boomer",
        "raredisplayname": "Enraged Brawlden Boomer",
        "aliases": ['boomer', 'boombox'],
        "class": enemy_class_shambler,
        "props": {
            'setdamage': 30000,
            'turncountdown': 2,
            'boomboxcountdown': 12,
            'boomboxbroken': 'false',
            'boomboxhealth': 100000
        }
    },
    enemy_type_juvieshambler: {
        "slimerange": [150000, 150000],
        "ai": enemy_ai_shambler,
        "attacktype": enemy_attacktype_gvs_s_teeth,
        "displayname": "Juvie Shambler",
        "raredisplayname": "NULL",
        "aliases": ['juvie', 'miner'],
        "class": enemy_class_shambler,
        "props": {
            'setdamage': 40000,
            'underground': 'true'
        }
    },
    enemy_type_shambleballplayer: {
        "slimerange": [250000, 250000],
        "ai": enemy_ai_shambler,
        "attacktype": enemy_attacktype_gvs_s_teeth,
        "displayname": "Shambleball Player",
        "raredisplayname": "NULL",
        "aliases": ['soccerguy', 'football', 'sports'],
        "class": enemy_class_shambler,
        "props": {
            'setdamage': 40000
        }
    },
    enemy_type_shamblerwarlord: {
        "slimerange": [300000, 300000],
        "ai": enemy_ai_shambler,
        "attacktype": enemy_attacktype_gvs_s_raiderscythe,
        "displayname": "Shambler Warlord",
        "raredisplayname": "NULL",
        "aliases": ['warlord'],
        "class": enemy_class_shambler,
        "props": {
            'setdamage': 60000,
            'summoncountdown': 3  # When it reaches 0, it is dialed back to 6
        }
    },
    enemy_type_shamblerraider: {
        "slimerange": [100000, 100000],
        "ai": enemy_ai_shambler,
        "attacktype": enemy_attacktype_gvs_s_raiderscythe,
        "displayname": "Shambler Raider",
        "raredisplayname": "NULL",
        "aliases": ['raider'],
        "class": enemy_class_shambler,
        "props": {
            'setdamage': 30000
        }
    },
    enemy_type_gvs_boss: {
        "slimerange": [5000000, 5000000],
        "ai": enemy_ai_shambler,
        "attacktype": enemy_attacktype_unarmed,
        "displayname": "PLACEHOLDER",
        "raredisplayname": "NULL",
        "aliases": ['placeholder'],
        "class": enemy_class_shambler,
        "props": {
            'onground': 'true',
            'setdamage': 100000
        }

        for enemy in gvs_enemies:
    enemy_drop_tables[enemy] = [{item_id_slimepoudrin: [100, 1, 1]}]


   # List of enemies used in the Gankers Vs. Shamblers event
gvs_enemies_gaiaslimeoids = [
    enemy_type_gaia_poketubers,
    enemy_type_gaia_pulpgourds,
    enemy_type_gaia_sourpotatoes,
    enemy_type_gaia_bloodcabbages,
    enemy_type_gaia_joybeans,
    enemy_type_gaia_purplekilliflower,
    enemy_type_gaia_razornuts,
    enemy_type_gaia_pawpaw,
    enemy_type_gaia_sludgeberries,
    enemy_type_gaia_suganmanuts,
    enemy_type_gaia_pinkrowddishes,
    enemy_type_gaia_dankwheat,
    enemy_type_gaia_brightshade,
    enemy_type_gaia_blacklimes,
    enemy_type_gaia_phosphorpoppies,
    enemy_type_gaia_direapples,
    enemy_type_gaia_rustealeaves,
    enemy_type_gaia_metallicaps,
    enemy_type_gaia_steelbeans,
    enemy_type_gaia_aushucks,
    enemy_type_gaia_partypoppeppers
]
gvs_enemies_shamblers = [
    enemy_type_defaultshambler,
    enemy_type_bucketshambler,
    enemy_type_juveolanternshambler,
    enemy_type_flagshambler,
    enemy_type_shambonidriver,
    enemy_type_mammoshambler,
    enemy_type_gigashambler,
    enemy_type_microshambler,
    enemy_type_shamblersaurusrex,
    enemy_type_shamblerdactyl,
    enemy_type_dinoshambler,
    enemy_type_ufoshambler,
    enemy_type_brawldenboomer,
    enemy_type_juvieshambler,
    enemy_type_shambleballplayer,
    enemy_type_shamblerwarlord,
    enemy_type_shamblerraider,
    enemy_type_gvs_boss,
]
gvs_enemies = gvs_enemies_gaiaslimeoids + gvs_enemies_shamblers
repairable_gaias = [
    enemy_type_gaia_blacklimes,
    enemy_type_gaia_razornuts,
    enemy_type_gaia_suganmanuts,
    enemy_type_gaia_steelbeans
]

# Gankers Vs. Shamblers enemies
enemy_type_gaia_poketubers = "poketubers"
enemy_type_gaia_pulpgourds = "pulpgourds"
enemy_type_gaia_sourpotatoes = "sourpotatoes"
enemy_type_gaia_bloodcabbages = "bloodcabbages"
enemy_type_gaia_joybeans = "joybeans"
enemy_type_gaia_purplekilliflower = "purplekilliflower"
enemy_type_gaia_razornuts = "razornuts"
enemy_type_gaia_pawpaw = "pawpaw"
enemy_type_gaia_sludgeberries = "sludgeberries"
enemy_type_gaia_suganmanuts = "suganmanuts"
enemy_type_gaia_pinkrowddishes = "pinkrowddishes"
enemy_type_gaia_dankwheat = "dankwheat"
enemy_type_gaia_brightshade = "brightshade"
enemy_type_gaia_blacklimes = "blacklimes"
enemy_type_gaia_phosphorpoppies = "phosphorpoppies"
enemy_type_gaia_direapples = "direapples"
enemy_type_gaia_rustealeaves = "rustealeaves"
enemy_type_gaia_metallicaps = "metallicaps"
enemy_type_gaia_steelbeans = "steelbeans"
enemy_type_gaia_aushucks = "aushucks"
# Smearg wanted this for flavor to keep the list complete UwU
enemy_type_gaia_partypoppeppers = "partypoppeppers"

enemy_type_defaultshambler = "defaultshambler"
enemy_type_bucketshambler = "bucketshambler"
enemy_type_juveolanternshambler = "juveolanternshambler"
enemy_type_flagshambler = "flagshambler"
enemy_type_shambonidriver = "shambonidriver"
enemy_type_mammoshambler = "mammoshambler"
enemy_type_gigashambler = "gigashambler"
enemy_type_microshambler = "microshambler"
enemy_type_shamblersaurusrex = "shamblesaurusrex"
enemy_type_shamblerdactyl = "shamblerdactyl"
enemy_type_dinoshambler = "dinoshambler"
enemy_type_ufoshambler = "ufoshambler"
enemy_type_brawldenboomer = "brawldenboomer"
enemy_type_juvieshambler = "juvieshambler"
enemy_type_shambleballplayer = "shambleballplayer"
enemy_type_shamblerwarlord = "shamblerwarlord"
enemy_type_shamblerraider = "shamblerraider"
enemy_type_gvs_boss = "blueeyesshamblerdragon"

enemy_attacktype_gvs_g_seeds = 'g_seeds'
enemy_attacktype_gvs_g_appleacid = 'g_appleacid'
enemy_attacktype_gvs_g_bloodshot = 'g_bloodshot'
enemy_attacktype_gvs_g_nuts = 'g_nuts'
enemy_attacktype_gvs_g_chompers = 'g_chompers'
enemy_attacktype_gvs_g_fists = 'g_fists'
enemy_attacktype_gvs_g_brainwaves = 'g_brainwaves'
enemy_attacktype_gvs_g_vapecloud = 'g_vapecloud'
enemy_attacktype_gvs_g_hotbox = 'g_hotbox'
enemy_attacktype_gvs_g_blades = 'g_blades'
enemy_attacktype_gvs_g_explosion = 'g_explosion'

enemy_attacktype_gvs_s_shamboni = 's_shamboni'
enemy_attacktype_gvs_s_teeth = 's_teeth'
enemy_attacktype_gvs_s_tusks = 's_tusks'
enemy_attacktype_gvs_s_fangs = 's_fangs'
enemy_attacktype_gvs_s_talons = 's_talons'
enemy_attacktype_gvs_s_molotovbreath = 's_molotovbreath'
enemy_attacktype_gvs_s_raiderscythe = 's_scythe'
enemy_attacktype_gvs_s_cudgel = 's_cudgel'
enemy_attacktype_gvs_s_grenadecannon = 's_grenadecannon'

def sh_check_coord_for_gaia(enemy_data, sh_range, direction):
    current_coord = enemy_data.gvs_coord
    gaias_in_coord = []

    if current_coord not in ewcfg.gvs_coords_end:

        for sh_row in ewcfg.gvs_valid_coords_shambler:

            if current_coord in sh_row:
                index = sh_row.index(current_coord)
                checked_coord = gvs_grid_gather_coords(enemy_data.enemyclass, sh_range, direction, sh_row, index)[0]

                for gaia_row in ewcfg.gvs_valid_coords_gaia:
                    if checked_coord in gaia_row:
                        # Check coordinate for gaiaslimeoids in front of the shambler.
                        gaia_data = bknd_core.execute_sql_query(
                            "SELECT {id_enemy}, {enemytype} FROM enemies WHERE {enemyclass} = %s AND {gvs_coord} = %s AND {poi} = %s AND {id_server} = %s AND NOT ({life_state} = {life_state_dead})".format(
                                id_enemy=ewcfg.col_id_enemy,
                                enemyclass=ewcfg.col_enemy_class,
                                enemytype=ewcfg.col_enemy_type,
                                gvs_coord=ewcfg.col_enemy_gvs_coord,
                                poi=ewcfg.col_poi,
                                id_server=ewcfg.col_id_server,
                                life_state=ewcfg.col_life_state,
                                life_state_dead=ewcfg.enemy_lifestate_dead,
                            ), (
                                ewcfg.enemy_class_gaiaslimeoid,
                                checked_coord,
                                enemy_data.poi,
                                enemy_data.id_server
                            ))

                        # print(len(gaia_data))
                        if len(gaia_data) > 0:

                            low_attack_priority = [ewcfg.enemy_type_gaia_rustealeaves]
                            high_attack_priority = [ewcfg.enemy_type_gaia_steelbeans]
                            mid_attack_priority = []
                            for enemy_id in ewcfg.gvs_enemies_gaiaslimeoids:
                                if enemy_id not in low_attack_priority and enemy_id not in high_attack_priority:
                                    mid_attack_priority.append(enemy_id)

                            gaia_types = {}
                            for gaia in gaia_data:
                                gaia_types[gaia[1]] = gaia[0]

                            # Rustea Leaves only have a few opposing shamblers that can damage them
                            if ewcfg.enemy_type_gaia_rustealeaves in gaia_types.keys() and enemy_data.enemytype not in [
                                ewcfg.enemy_type_gigashambler, ewcfg.enemy_type_shambonidriver,
                                ewcfg.enemy_type_ufoshambler]:
                                del gaia_types[ewcfg.enemy_type_gaia_rustealeaves]

                            for target in high_attack_priority:
                                if target in gaia_types.keys():
                                    gaias_in_coord.append(gaia_types[target])

                            for target in mid_attack_priority:
                                if target in gaia_types.keys():
                                    gaias_in_coord.append(gaia_types[target])

                            for target in low_attack_priority:
                                if target in gaia_types.keys():
                                    gaias_in_coord.append(gaia_types[target])

                # print('shambler in coord {} found gaia in coord {} in {}.'.format(current_coord, checked_coord, enemy_data.poi))

    return gaias_in_coord


def gvs_grid_gather_coords(enemyclass, gr_range, direction, row, index):
    checked_coords = []

    if enemyclass == ewcfg.enemy_class_shambler:
        index_change = -2
        if direction == 'right':
            index_change *= -1

        try:
            checked_coords.append(row[index + index_change])
        except:
            pass

    else:

        index_changes = []

        # Default if range is 1, only reaches 0.5 and 1 full tile ahead
        for i in range(gr_range):
            index_changes.append(i + 1)

        # If it reaches backwards with a range of 1, reflect current index changes
        if direction == 'left':
            new_index_changes = []

            for change in index_changes:
                change *= -1
                new_index_changes.append(change)

            index_changes = new_index_changes

        # If it reaches both directions with a range of 1, add in opposite tiles.
        elif direction == 'frontandback':
            new_index_changes = []

            for change in index_changes:
                change *= -1
                new_index_changes.append(change)

            index_changes += new_index_changes

        # If it attacks in a ring formation around itself, there are no coord changes.
        # The proper coordinates will be fetched later as 'splash' damage.
        elif direction == 'ring':
            index_changes = [0]

        # Catch exceptions when necessary
        for index_change in index_changes:
            try:
                checked_coords.append(row[index + index_change])
            except:
                pass

    # print(index_changes)

    # print(gr_range)
    # print(checked_coords)
    # print(enemyclass)

    return checked_coords


def gvs_find_nearest_shambler(checked_coords, detected_shamblers, pierceamount = 1, singletilepierce = 'false'):
    pierceattempts = 0
    current_dict = {}
    chosen_coord = ''

    for coord in checked_coords:
        for shambler in detected_shamblers.keys():
            if detected_shamblers[shambler] == coord:
                current_dict[shambler] = coord

                if singletilepierce == 'true':
                    chosen_coord = coord
                    for shambler in detected_shamblers.keys():
                        if detected_shamblers[shambler] == chosen_coord:
                            current_dict[shambler] = chosen_coord
                        pierceattempts += 1
                        if pierceattempts == pierceamount:
                            return current_dict

            pierceattempts += 1
            if pierceattempts == pierceamount:
                return current_dict


def gvs_get_splash_coords(checked_splash_coords):
    # Grab any random coordinate from the supplied splash coordinates, then get the row that it's in.
    plucked_coord = checked_splash_coords[0]
    plucked_row = plucked_coord[0]
    top_row = None
    middle_row = None
    bottom_row = None

    extra_top_row = None  # Joybean Pawpaw
    extra_bottom_row = None  # Joybean Pawpaw
    row_range = 5  # Joybean Dankwheat = 9
    row_backpedal = 2  # Joybean Dankwheat = 4

    current_index = 0

    all_splash_coords = []
    if plucked_row == 'A':
        middle_row = 0
        bottom_row = 1
    elif plucked_row == 'B':
        top_row = 0
        middle_row = 1
        bottom_row = 2
    elif plucked_row == 'C':
        top_row = 1
        middle_row = 2
        bottom_row = 3
    elif plucked_row == 'D':
        top_row = 2
        middle_row = 3
        bottom_row = 4
    elif plucked_row == 'E':
        top_row = 3
        middle_row = 4

    for coord in checked_splash_coords:
        for sh_row in ewcfg.gvs_valid_coords_shambler:
            if coord in sh_row:
                current_index = sh_row.index(coord)
                break

        if top_row != None:
            for i in range(row_range):
                try:
                    all_splash_coords.append(
                        ewcfg.gvs_valid_coords_shambler[top_row][current_index - row_backpedal + i])
                except:
                    pass
        if bottom_row != None:
            for i in range(row_range):
                try:
                    all_splash_coords.append(
                        ewcfg.gvs_valid_coords_shambler[bottom_row][current_index - row_backpedal + i])
                except:
                    pass

        for i in range(row_range):
            try:
                all_splash_coords.append(ewcfg.gvs_valid_coords_shambler[middle_row][current_index - row_backpedal + i])
            except:
                pass

    return all_splash_coords


    def ga_check_coord_for_shambler(enemy_data, ga_range, direction, piercing, splash, pierceamount, singletilepierce):
    current_coord = enemy_data.gvs_coord
    detected_shamblers = {}

    for sh_row in ewcfg.gvs_valid_coords_shambler:

        if current_coord in sh_row:
            index = sh_row.index(current_coord)
            checked_coords = gvs_grid_gather_coords(enemy_data.enemyclass, int(ga_range), direction, sh_row, index)

            # print('GAIA -- CHECKED COORDS FOR {} WITH ID {}: {}'.format(enemy_data.enemytype, enemy_data.id_enemy, checked_coords))

            # Check coordinate for shamblers in range of gaiaslimeoid.
            shambler_data = bknd_core.execute_sql_query(
                "SELECT {id_enemy}, {enemytype} FROM enemies WHERE {enemyclass} = %s AND {gvs_coord} IN %s AND {poi} = %s AND {id_server} = %s AND NOT ({life_state} = {life_state_dead} OR {life_state} = {life_state_unactivated})".format(
                    id_enemy=ewcfg.col_id_enemy,
                    enemyclass=ewcfg.col_enemy_class,
                    enemytype=ewcfg.col_enemy_type,
                    gvs_coord=ewcfg.col_enemy_gvs_coord,
                    poi=ewcfg.col_poi,
                    id_server=ewcfg.col_id_server,
                    life_state=ewcfg.col_life_state,
                    life_state_dead=ewcfg.enemy_lifestate_dead,
                    life_state_unactivated=ewcfg.enemy_lifestate_unactivated,
                ), (
                    ewcfg.enemy_class_shambler,
                    tuple(checked_coords),
                    enemy_data.poi,
                    enemy_data.id_server
                ))

            # print(len(shambler_data))
            if len(shambler_data) > 0:

                for shambler in shambler_data:

                    current_shambler_data = EwEnemyBase(id_enemy=shambler[0], id_server=enemy_data.id_server)
                    detected_shamblers[current_shambler_data.id_enemy] = current_shambler_data.gvs_coord

                    if shambler[1] in [ewcfg.enemy_type_juvieshambler] and current_shambler_data.enemy_props.get(
                            'underground') == 'true':
                        del detected_shamblers[current_shambler_data.id_enemy]

                if piercing == 'false':
                    detected_shamblers = gvs_find_nearest_shambler(checked_coords, detected_shamblers)
                elif int(pierceamount) > 0:
                    detected_shamblers = gvs_find_nearest_shambler(checked_coords, detected_shamblers, pierceamount,
                                                                   singletilepierce)

            # print('gaia in coord {} found shambler in coords {} in {}.'.format(current_coord, checked_coords, enemy_data.poi))

            if splash == 'true':

                if detected_shamblers == {}:
                    checked_splash_coords = checked_coords
                else:
                    checked_splash_coords = []
                    for shambler in detected_shamblers.keys():
                        checked_splash_coords.append(detected_shamblers[shambler])

                splash_coords = gvs_get_splash_coords(checked_splash_coords)

                splash_shambler_data = bknd_core.execute_sql_query(
                    "SELECT {id_enemy}, {enemytype}, {gvs_coord} FROM enemies WHERE {enemyclass} = %s AND {gvs_coord} IN %s AND {poi} = %s AND {id_server} = %s".format(
                        id_enemy=ewcfg.col_id_enemy,
                        enemyclass=ewcfg.col_enemy_class,
                        enemytype=ewcfg.col_enemy_type,
                        gvs_coord=ewcfg.col_enemy_gvs_coord,
                        poi=ewcfg.col_poi,
                        id_server=ewcfg.col_id_server,
                    ), (
                        ewcfg.enemy_class_shambler,
                        tuple(splash_coords),
                        enemy_data.poi,
                        enemy_data.id_server
                    ))

                for splashed_shambler in splash_shambler_data:
                    detected_shamblers[splashed_shambler[0]] = splashed_shambler[2]
            break

    return detected_shamblers

def gvs_create_gaia_grid_mapping(user_data):
    grid_map = {}

    # Grid print mapping and shambler targeting use different priority lists. Don't get these mixed up
    printgrid_low_priority = [ewcfg.enemy_type_gaia_rustealeaves]
    printgrid_mid_priority = [ewcfg.enemy_type_gaia_steelbeans]
    printgrid_high_priority = []
    for enemy_id in ewcfg.gvs_enemies_gaiaslimeoids:
        if enemy_id not in printgrid_low_priority and enemy_id not in printgrid_mid_priority:
            printgrid_high_priority.append(enemy_id)

    gaias = bknd_core.execute_sql_query(
        "SELECT {id_enemy}, {enemytype}, {gvs_coord} FROM enemies WHERE id_server = %s AND {poi} = %s AND {life_state} = 1 AND {enemyclass} = %s".format(
            id_enemy=ewcfg.col_id_enemy,
            enemytype=ewcfg.col_enemy_type,
            poi=ewcfg.col_enemy_poi,
            life_state=ewcfg.col_enemy_life_state,
            gvs_coord=ewcfg.col_enemy_gvs_coord,
            enemyclass=ewcfg.col_enemy_class,
        ), (
            user_data.id_server,
            user_data.poi,
            ewcfg.enemy_class_gaiaslimeoid
        ))

    grid_conditions = bknd_core.execute_sql_query(
        "SELECT coord, grid_condition FROM gvs_grid_conditions WHERE district = %s".format(
        ), (
            user_data.poi,
        ))

    for condition in grid_conditions:
        grid_map[condition[0]] = condition[1]

    for gaia in gaias:
        try:
            gaia_in_coord = grid_map[gaia[2]]
            # No key error: Gaia is in coord already, check for priority
            is_filled = True
        except KeyError:
            gaia_in_coord = ''
            # Key error: Gaia was not in coord
            is_filled = False

        if is_filled:
            if gaia_in_coord in printgrid_low_priority and (gaia[1] in printgrid_mid_priority or gaia[1] in printgrid_high_priority):
                grid_map[gaia[2]] = gaia[1]
            if gaia_in_coord in printgrid_mid_priority and gaia[1] in printgrid_high_priority:
                grid_map[gaia[2]] = gaia[1]
        else:
            grid_map[gaia[2]] = gaia[1]

    return grid_map


def gvs_create_gaia_lane_mapping(user_data, row_used):
    # Grid print mapping and shambler targeting use different priority lists. Don't get these mixed up
    printlane_low_priority = [ewcfg.enemy_type_gaia_rustealeaves]
    printlane_mid_priority = []
    printlane_high_priority = [ewcfg.enemy_type_gaia_steelbeans]
    for enemy_id in ewcfg.gvs_enemies_gaiaslimeoids:
        if enemy_id not in printlane_low_priority and enemy_id not in printlane_high_priority:
            printlane_mid_priority.append(enemy_id)

    gaias = bknd_core.execute_sql_query(
        "SELECT {id_enemy}, {enemytype}, {gvs_coord} FROM enemies WHERE id_server = %s AND {poi} = %s AND {life_state} = 1 AND {enemyclass} = %s AND {gvs_coord} IN %s".format(
            id_enemy=ewcfg.col_id_enemy,
            enemytype=ewcfg.col_enemy_type,
            poi=ewcfg.col_enemy_poi,
            life_state=ewcfg.col_enemy_life_state,
            gvs_coord=ewcfg.col_enemy_gvs_coord,
            enemyclass=ewcfg.col_enemy_class,
        ), (
            user_data.id_server,
            user_data.poi,
            ewcfg.enemy_class_gaiaslimeoid,
            tuple(row_used)
        ))

    grid_conditions = bknd_core.execute_sql_query(
        "SELECT coord, grid_condition FROM gvs_grid_conditions WHERE district = %s AND coord IN %s".format(
        ), (
            user_data.poi,
            tuple(row_used)
        ))

    coord_sets = []

    for coord in row_used:
        current_coord_set = []
        for enemy in printlane_low_priority:
            for gaia in gaias:
                if gaia[1] == enemy and gaia[2] == coord:
                    current_coord_set.append(gaia[0])

        for enemy in printlane_mid_priority:
            for gaia in gaias:
                if gaia[1] == enemy and gaia[2] == coord:
                    current_coord_set.append(gaia[0])

        for enemy in printlane_high_priority:
            for gaia in gaias:
                if gaia[1] == enemy and gaia[2] == coord:
                    current_coord_set.append(gaia[0])

        for condition in grid_conditions:
            if condition[0] == coord:
                if condition[1] == 'frozen':
                    current_coord_set.append('frozen')

        coord_sets.append(current_coord_set)

    return coord_sets


def gvs_check_gaia_protected(enemy_data):
    is_protected = False

    low_attack_priority = [ewcfg.enemy_type_gaia_rustealeaves]
    high_attack_priority = [ewcfg.enemy_type_gaia_steelbeans]
    mid_attack_priority = []
    for enemy_id in ewcfg.gvs_enemies_gaiaslimeoids:
        if enemy_id not in low_attack_priority and enemy_id not in high_attack_priority:
            mid_attack_priority.append(enemy_id)

    checked_coords = []
    enemy_coord = enemy_data.gvs_coord
    for row in ewcfg.gvs_valid_coords_gaia:
        if enemy_coord in row:
            index = row.index(enemy_coord)
            row_length = len(ewcfg.gvs_valid_coords_gaia)
            for i in range(index + 1, row_length):
                checked_coords.append(ewcfg.gvs_valid_coords_gaia[i])

    gaias_in_front_coords = bknd_core.execute_sql_query(
        "SELECT {id_enemy}, {enemytype}, {gvs_coord} FROM enemies WHERE {life_state} = 1 AND {enemyclass} = %s AND {gvs_coord} IN %s".format(
            id_enemy=ewcfg.col_id_enemy,
            enemytype=ewcfg.col_enemy_type,
            life_state=ewcfg.col_enemy_life_state,
            gvs_coord=ewcfg.col_enemy_gvs_coord,
            enemyclass=ewcfg.col_enemy_class,
        ), (
            ewcfg.enemy_class_gaiaslimeoid,
            tuple(checked_coords)
        ))

    if len(gaias_in_front_coords) > 0:
        is_protected = True
    else:
        gaias_in_same_coord = bknd_core.execute_sql_query(
            "SELECT {id_enemy}, {enemytype}, {gvs_coord} FROM enemies WHERE {life_state} = 1 AND {enemyclass} = %s AND {gvs_coord} = %s".format(
                id_enemy=ewcfg.col_id_enemy,
                enemytype=ewcfg.col_enemy_type,
                life_state=ewcfg.col_enemy_life_state,
                gvs_coord=ewcfg.col_enemy_gvs_coord,
                enemyclass=ewcfg.col_enemy_class,
            ), (
                ewcfg.enemy_class_gaiaslimeoid,
                enemy_coord
            ))
        if len(gaias_in_same_coord) > 1:
            same_coord_gaias_types = []
            for gaia in gaias_in_same_coord:
                same_coord_gaias_types.append(gaia[1])

            for type in same_coord_gaias_types:
                if enemy_data.enemy_type in high_attack_priority:
                    is_protected = False
                    break
                elif enemy_data.enemy_type in mid_attack_priority and type in high_attack_priority:
                    is_protected = True
                    break
                elif enemy_data.enemy_type in low_attack_priority and (type in mid_attack_priority or type in high_attack_priority):
                    is_protected = True
                    break

        else:
            is_protected = False

    return is_protected


def gvs_check_operation_duplicate(id_user, district, enemytype, faction):
    entry = None

    if faction == ewcfg.psuedo_faction_gankers:
        entry = bknd_core.execute_sql_query(
            "SELECT * FROM gvs_ops_choices WHERE id_user = %s AND district = %s AND enemytype = %s AND faction = %s".format(
            ), (
                id_user,
                district,
                enemytype,
                faction
            ))
    elif faction == ewcfg.psuedo_faction_shamblers:
        entry = bknd_core.execute_sql_query(
            "SELECT * FROM gvs_ops_choices WHERE district = %s AND enemytype = %s AND faction = %s".format(
            ), (
                district,
                enemytype,
                faction
            ))

    if len(entry) > 0:
        return True
    else:
        return False


def gvs_check_operation_limit(id_user, district, enemytype, faction):
    limit_hit = False
    tombstone_limit = 0

    if faction == ewcfg.psuedo_faction_gankers:
        data = bknd_core.execute_sql_query(
            "SELECT id_user FROM gvs_ops_choices WHERE id_user = %s AND district = %s AND faction = %s".format(
            ), (
                id_user,
                district,
                faction
            ))

        if len(data) >= 6:
            limit_hit = True
        else:
            limit_hit = False

    elif faction == ewcfg.psuedo_faction_shamblers:
        sh_data = bknd_core.execute_sql_query(
            "SELECT enemytype FROM gvs_ops_choices WHERE district = %s AND faction = %s".format(
            ), (
                district,
                faction
            ))

        gg_data = bknd_core.execute_sql_query(
            "SELECT id_user FROM gvs_ops_choices WHERE district = %s AND faction = %s".format(
            ), (
                district,
                enemytype,
            ))

        gg_id_list = []
        for gg in gg_data:
            gg_id_list.append(gg[0])

        gg_id_set = set(gg_id_list)  # Remove duplicate user IDs

        if len(gg_id_set) == 0:
            tombstone_limit = 3
        elif len(gg_id_set) <= 3:
            tombstone_limit = 6
        elif len(gg_id_set) <= 6:
            tombstone_limit = 10
        else:
            tombstone_limit = 12

        if len(sh_data) >= tombstone_limit:
            limit_hit = True
        else:
            limit_hit = False

    return limit_hit, tombstone_limit


def gvs_check_if_in_operation(user_data):
    op_data = bknd_core.execute_sql_query(
        "SELECT id_user, district FROM gvs_ops_choices WHERE id_user = %s".format(
        ), (
            user_data.id_user,
        ))

    if len(op_data) > 0:
        return True, op_data[0][1]
    else:
        return False, None


def gvs_get_gaias_from_coord(poi, checked_coord):
    gaias = bknd_core.execute_sql_query(
        "SELECT id_enemy, enemytype FROM enemies WHERE poi = %s AND gvs_coord = %s".format(
        ), (
            poi,
            checked_coord
        ))

    gaias_id_to_type_map = {}

    for gaia in gaias:
        if gaia[1] in ewcfg.gvs_enemies_gaiaslimeoids:
            gaias_id_to_type_map[gaia[0]] = gaia[1]

    return gaias_id_to_type_map


# If there are no player operations, spawn in ones that the bot uses
def gvs_insert_bot_ops(id_server, district, enemyfaction):
    bot_id = 56709

    if enemyfaction == ewcfg.psuedo_faction_gankers:
        possible_bot_types = [
            ewcfg.enemy_type_gaia_pinkrowddishes,
            ewcfg.enemy_type_gaia_purplekilliflower,
            ewcfg.enemy_type_gaia_poketubers,
            ewcfg.enemy_type_gaia_razornuts
        ]
        for type in possible_bot_types:
            bknd_core.execute_sql_query("REPLACE INTO gvs_ops_choices({}, {}, {}, {}, {}, {}) VALUES(%s, %s, %s, %s, %s, %s)".format(
                ewcfg.col_id_user,
                ewcfg.col_district,
                ewcfg.col_enemy_type,
                ewcfg.col_faction,
                ewcfg.col_id_item,
                ewcfg.col_shambler_stock,
            ), (
                bot_id,
                district,
                type,
                enemyfaction,
                -1,
                0,
            ))

            # To increase the challenge, a column of suganmanuts is placed down.
            for coord in ['A6', 'B6', 'C6', 'D6', 'E6']:
                spawn_enemy(
                    id_server=id_server,
                    pre_chosen_type=ewcfg.enemy_type_gaia_suganmanuts,
                    pre_chosen_level=50,
                    pre_chosen_poi=district,
                    pre_chosen_identifier='',
                    pre_chosen_faction=ewcfg.psuedo_faction_gankers,
                    pre_chosen_owner=bot_id,
                    pre_chosen_coord=coord,
                    manual_spawn=True,
                )

    elif enemyfaction == ewcfg.psuedo_faction_shamblers:
        possible_bot_types = [
            ewcfg.enemy_type_defaultshambler,
            ewcfg.enemy_type_bucketshambler,
        ]
        for type in possible_bot_types:
            bknd_core.execute_sql_query("REPLACE INTO gvs_ops_choices({}, {}, {}, {}, {}, {}) VALUES(%s, %s, %s, %s, %s, %s)".format(
                ewcfg.col_id_user,
                ewcfg.col_district,
                ewcfg.col_enemy_type,
                ewcfg.col_faction,
                ewcfg.col_id_item,
                ewcfg.col_shambler_stock,
            ), (
                bot_id,
                district,
                type,
                enemyfaction,
                -1,
                20,
            ))


# This function takes care of all win conditions within Gankers Vs. Shamblers.
# It also handles turn counters, including gaiaslime generation, as well as spawning in shamblers
async def gvs_update_gamestate(id_server):
    op_districts = bknd_core.execute_sql_query("SELECT district FROM gvs_ops_choices GROUP BY district")
    for op_district in op_districts:
        district = op_district[0]

        graveyard_ops = bknd_core.execute_sql_query(
            "SELECT id_user, enemytype, shambler_stock FROM gvs_ops_choices WHERE faction = 'shamblers' AND district = '{}' AND shambler_stock > 0".format(
                district))
        bot_garden_ops = bknd_core.execute_sql_query(
            "SELECT id_user, enemytype FROM gvs_ops_choices WHERE faction = 'gankers' AND district = '{}' AND id_user = 56709".format(
                district))
        op_district_data = EwDistrict(district=district, id_server=id_server)

        # Generate Gaiaslime passively over time, but in small amounts
        op_district_data.gaiaslime += 5
        op_district_data.persist()

        victor = None
        time_now = int(time.time())

        op_poi = poi_static.id_to_poi.get(district)
        client = ewutils.get_client()
        server = client.get_guild(id_server)
        channel = fe_utils.get_channel(server, op_poi.channel)

        if len(bot_garden_ops) > 0:
            if random.randrange(25) == 0:

                # random_op = random.choice(bot_garden_ops)
                # random_op_data = EwOperationData(id_user=random_op[0], district=district, enemytype=random_op[1])

                possible_bot_types = [
                    ewcfg.enemy_type_gaia_suganmanuts,
                    ewcfg.enemy_type_gaia_pinkrowddishes,
                    ewcfg.enemy_type_gaia_purplekilliflower,
                    ewcfg.enemy_type_gaia_poketubers,
                    ewcfg.enemy_type_gaia_razornuts
                ]

                possible_bot_coords = [
                    'A1', 'A2', 'A3', 'A4', 'A5',
                    'B1', 'B2', 'B3', 'B4', 'B5',
                    'C1', 'C2', 'C3', 'C4', 'C5',
                    'D1', 'D2', 'D3', 'D4', 'D5',
                    'E1', 'E2', 'E3', 'E4', 'E5'
                ]

                for i in range(5):
                    chosen_type = random.choice(possible_bot_types)
                    chosen_coord = random.choice(possible_bot_coords)

                    existing_gaias = gvs_get_gaias_from_coord(district, chosen_coord)

                    # If the coordinate is completely empty, spawn a gaiaslimeoid there.
                    # Otherwise, make up to 5 attempts when choosing random coordinates
                    if len(existing_gaias) == 0:
                        resp_cont = spawn_enemy(
                            id_server=id_server,
                            pre_chosen_type=chosen_type,
                            pre_chosen_level=50,
                            pre_chosen_poi=district,
                            pre_chosen_identifier='',
                            pre_chosen_faction=ewcfg.psuedo_faction_gankers,
                            pre_chosen_owner=56709,
                            pre_chosen_coord=chosen_coord,
                            manual_spawn=True,
                        )
                        await resp_cont.post()

                        break

        if len(graveyard_ops) > 0:

            # The chance for a shambler to spawn is inversely proportional to the amount of shamblers left in stock
            # The less shamblers there are left, the more likely they are to spawn
            current_stock = 0
            full_stock = 0

            for op in graveyard_ops:
                current_stock += op[2]
                full_stock += static_items.tombstone_fullstock_map[op[1]]

            # Example: If full_stock is 50, and current_stock is 20, then the spawn chance is 70%
            # ((1 - (20 / 50)) * 100) + 10 = 70

            shambler_spawn_chance = int(((1 - (current_stock / full_stock)) * 100) + 10)
            if random.randrange(100) + 1 < shambler_spawn_chance:

                random_op = random.choice(graveyard_ops)
                random_op_data = EwOperationData(id_user=random_op[0], district=district, enemytype=random_op[1])

                # Don't spawn if there aren't available identifiers
                if len(op_district_data.get_enemies_in_district(classes=[ewcfg.enemy_class_shambler])) < 26:
                    resp_cont = spawn_enemy(
                        id_server=id_server,
                        pre_chosen_type=random_op_data.enemytype,
                        pre_chosen_level=50,
                        pre_chosen_poi=district,
                        pre_chosen_faction=ewcfg.psuedo_faction_shamblers,
                        pre_chosen_owner=random_op_data.id_user,
                        pre_chosen_coord=random.choice(ewcfg.gvs_coords_start),
                        manual_spawn=True
                    )

                    random_op_data.shambler_stock -= 1
                    random_op_data.persist()

                    if random_op_data.shambler_stock == 0:
                        breakdown_response = "The tombstone spawning in {}s breaks down and collapses!".format(
                            random_op_data.enemytype.capitalize())
                        resp_cont.add_channel_response(channel, breakdown_response)
                    else:
                        random_op_data.persist()

                    await resp_cont.post()
        else:
            shamblers = bknd_core.execute_sql_query(
                "SELECT id_enemy FROM enemies WHERE enemyclass = '{}' AND poi = '{}'".format(ewcfg.enemy_class_shambler,
                                                                                             district))
            if len(shamblers) == 0:
                # No more stocked tombstones, and no more enemy shamblers. Garden Gankers win!
                victor = ewcfg.psuedo_faction_gankers

        op_juvies = bknd_core.execute_sql_query(
            "SELECT id_user FROM gvs_ops_choices WHERE faction = 'gankers' AND district = '{}' AND id_user != 56709 GROUP BY id_user".format(
                district))

        # No more Garden Gankers left. Shamblers win?
        if len(op_juvies) == 0:

            # Check if the shamblers are fighting against the bot.
            # If they are, they can only win if at least one shambler has reached the back.
            if len(bot_garden_ops) > 0:
                back_shamblers = bknd_core.execute_sql_query(
                    "SELECT id_enemy FROM enemies WHERE gvs_coord IN {}".format(tuple(ewcfg.gvs_coords_end)))
                if len(back_shamblers) > 0:
                    # Shambler reached the back while no juveniles were around to help the bot. Shamblers win!
                    victor = ewcfg.psuedo_faction_shamblers
            else:
                # No juveniles left in the district, and there were no bot operations. Shamblers win!
                victor = ewcfg.psuedo_faction_shamblers

        all_garden_ops = bknd_core.execute_sql_query(
            "SELECT id_user FROM gvs_ops_choices WHERE faction = 'gankers' AND district = '{}'".format(district))
        # No garden ops at all. Shamblers win!
        if len(all_garden_ops) == 0:
            victor = ewcfg.psuedo_faction_shamblers

        if victor != None:
            if victor == ewcfg.psuedo_faction_gankers:
                response = "***All tombstones have been emptied out! The Garden Gankers take victory!\nThe district is rejuvenated completely!!***"

                for juvie in op_juvies:
                    ewutils.active_restrictions[juvie[0]] = 0

                op_district_data.gaiaslime = 0
                op_district_data.degradation = 0
                op_district_data.time_unlock = time_now + 3600
                op_district_data.persist()
            else:
                response = "***The shamblers have eaten the brainz of the Garden Gankers and take control of the district!\nIt's shambled completely!!***"
                op_district_data.gaiaslime = 0
                op_district_data.degradation = ewcfg.district_max_degradation
                op_district_data.time_unlock = time_now + 3600
                op_district_data.persist()

            bknd_core.execute_sql_query("DELETE FROM gvs_ops_choices WHERE district = '{}'".format(district))
            await bknd_hunt.delete_all_enemies(cmd=None, query_suffix="AND poi = '{}'".format(district), id_server_sent=id_server)
            return await fe_utils.send_message(client, channel, response)


# Certain conditions may prevent a shambler from acting.
def check_enemy_can_act(enemy_data):
    enemy_props = enemy_data.enemy_props

    turn_countdown = enemy_props.get('turncountdown')
    dank_countdown = enemy_props.get('dankcountdown')
    sludge_countdown = enemy_props.get('sludgecountdown')
    hardened_sludge_countdown = enemy_props.get('hardsludgecountdown')

    waiting = False
    stoned = False
    sludged = False
    hardened = False

    if turn_countdown != None:
        if int(turn_countdown) > 0:
            waiting = True
            enemy_props['turncountdown'] -= 1
        else:
            waiting = False

    if dank_countdown != None:
        if int(dank_countdown) > 0:
            # If the countdown number is even, they can act. Otherwise, they cannot.
            if dank_countdown % 2 == 0:
                stoned = False
            else:
                stoned = True

            enemy_props['dankcountdown'] -= 1
        else:
            stoned = False

    # Regular sludge only slows a shambler down every other turn. Hardened sludge immobilizes them completely.
    if sludge_countdown != None:
        if int(sludge_countdown) > 0:
            # If the countdown number is even, they can act. Otherwise, they cannot.
            if sludge_countdown % 2 == 0:
                sludged = False
            else:
                sludged = True

            enemy_props['sludgecountdown'] -= 1
        else:
            sludged = False

    if hardened_sludge_countdown != None:
        if int(hardened_sludge_countdown) > 0:
            hardened = True
            enemy_props['hardsludgecountdown'] -= 1
        else:
            hardened = False

    enemy_data.persist()

    if not waiting and not stoned and not sludged and not hardened:
        return True
    else:
        return False


def handle_turn_timers(enemy_data):
    response = ""

    # Handle specific turn counters of all GvS enemies.
    if enemy_data.enemytype == ewcfg.enemy_type_gaia_brightshade:
        countdown = enemy_data.enemy_props.get('gaiaslimecountdown')

        if countdown != None:
            int_countdown = int(countdown)

            if int_countdown == 0:

                gaiaslime_amount = 0

                enemy_data.enemy_props['gaiaslimecountdown'] = 2
                district_data = EwDistrict(district=enemy_data.poi, id_server=enemy_data.id_server)

                if enemy_data.enemy_props.get('joybean') != None:
                    if enemy_data.enemy_props.get('joybean') == 'true':
                        gaiaslime_amount = 50
                    else:
                        gaiaslime_amount = 25
                else:
                    gaiaslime_amount = 25

                district_data.gaiaslime += gaiaslime_amount
                district_data.persist()

                response = "{} ({}) produced {} gaiaslime!".format(enemy_data.display_name, enemy_data.gvs_coord,
                                                                   gaiaslime_amount)

            else:
                enemy_data.enemy_props['gaiaslimecountdown'] = int_countdown - 1

            enemy_data.persist()
            return response

    elif enemy_data.enemytype == ewcfg.enemy_type_gaia_poketubers:

        countdown = enemy_data.enemy_props.get('primecountdown')

        if countdown != None:
            int_countdown = int(countdown)

            if enemy_data.enemy_props.get('primed') != 'true':

                if int_countdown == 0:
                    enemy_data.enemy_props['primed'] = 'true'

                    response = "{} ({}) is primed and ready.".format(enemy_data.display_name, enemy_data.gvs_coord)

                else:
                    enemy_data.enemy_props['primecountdown'] = int_countdown - 1

                enemy_data.persist()
                return response


async def sh_move(enemy_data):
    current_coord = enemy_data.gvs_coord
    has_moved = False
    index = None
    row = None
    new_coord = None

    if current_coord in ewcfg.gvs_coords_start and enemy_data.enemytype == ewcfg.enemy_type_juvieshambler:
        bknd_hunt.delete_enemy(enemy_data)

    if current_coord not in ewcfg.gvs_coords_end:
        for row in ewcfg.gvs_valid_coords_shambler:

            if current_coord in row:
                index = row.index(current_coord)
                new_coord = row[index - 1]
                # print(new_coord)
                break

        if new_coord == None:
            return

        enemy_data.gvs_coord = new_coord
        enemy_data.persist()

        for gaia_row in ewcfg.gvs_valid_coords_gaia:
            if new_coord in gaia_row and index != None and row != None:
                poi_channel = poi_static.id_to_poi.get(enemy_data.poi).channel

                try:
                    previous_gaia_coord = row[index - 2]
                except:
                    break

                response = "The {} moved from {} to {}!".format(enemy_data.display_name, new_coord, previous_gaia_coord)
                client = ewutils.get_client()
                server = client.get_guild(enemy_data.id_server)
                channel = fe_utils.get_channel(server, poi_channel)

                await fe_utils.send_message(client, channel, response)

    # print('shambler moved from {} to {} in {}.'.format(current_coord, new_coord, enemy_data.poi))

    return has_moved
 # If str_trauma and str_trauma_self make a return, consider filling GvS attacktypes out in these attributes.
    EwAttackType(  # GvS - 1
        id_type="g_seeds",
        str_crit="NULL",
        str_miss="**MISS!** {name_enemy}'s seeds completely miss {name_target}!",
        # str_trauma_self = "NULL",
        # str_trauma = "NULL,
        str_kill="{name_enemy}'s seeds land right inside {name_target}'s skull, killing them instantly. {emote_skull}",
        str_killdescriptor="seeded",
        str_damage="{name_target} is pummeled with seeds on their {hitzone}!",
        str_groupattack="{name_target} pummels a whole group of shamblers with their seeds!",
        fn_effect=atf_gvs_basic
    ),
    EwAttackType(  # GvS - 1.5
        id_type="g_appleacid",
        str_crit="NULL",
        str_miss="**MISS!** {name_enemy}'s acid completely misses {name_target}!",
        # str_trauma_self = "NULL",
        # str_trauma = "NULL,
        str_kill="{name_enemy} hurls a glob of acid straight onto {name_target}'s chest, melting down their insides. {emote_skull}",
        str_killdescriptor="melted down to the bone",
        str_damage="{name_target} is drenched with acid on their {hitzone}!",
        str_groupattack="{name_target} drenches a group of shamblers with their acid!",
        fn_effect=atf_gvs_basic
    ),
    EwAttackType(  # GvS - 2
        id_type="g_bloodshot",
        str_crit="NULL",
        str_miss="**MISS!** {name_enemy}'s bloodshot dissipates in mid-air as it fails to seek out {name_target}!",
        # str_trauma_self = "NULL",
        # str_trauma = "NULL,
        str_kill="{name_enemy} turns {name_target} into a shriveled up husk! {emote_skull}",
        str_killdescriptor="drained",
        str_damage="{name_target} has their life essence drained away by {name_enemy}!",
        str_groupattack="{name_enemy} sucks the life force out of a group of shamblers!",
        fn_effect=atf_gvs_basic
    ),
    EwAttackType(  # GvS - 3
        id_type="g_nuts",
        str_crit="NULL",
        str_miss="**MISS!** {name_enemy}'s nuts don't even come close to hitting {name_target}!",
        # str_trauma_self = "NULL",
        # str_trauma = "NULL,
        str_kill="{name_enemy}'s nuts knock {name_target}'s head clean off! {emote_skull}",
        str_killdescriptor="conked on the head",
        str_damage="{name_enemy}'s nuts bonk {name_target} on their {hitzone}!",
        str_groupattack="{name_enemy}'s nuts richochet off of a group of shamblers!",
        fn_effect=atf_gvs_basic
    ),
    EwAttackType(  # GvS - 4
        id_type="g_chompers",
        str_crit="NULL",
        str_miss="**MISS!** {name_enemy}'s gaping maw snaps shut!",
        # str_trauma_self = "NULL",
        # str_trauma = "NULL,
        str_kill="**CHOMP!** {name_enemy} devours {name_target}, killing them instantly. {emote_skull}",
        str_killdescriptor="chomped",
        str_damage="{name_enemy}'s chompers take a bite out of {name_target}!",
        str_groupattack="{name_enemy} is running wild!! Their chompers lay waste to a group of shamblers!",
        fn_effect=atf_gvs_basic
    ),
    EwAttackType(  # GvS - 5
        id_type="g_fists",
        str_crit="NULL",
        str_miss="**MISS!** {name_enemy} thrashes about, but fails to hit {name_target}.",
        # str_trauma_self = "NULL",
        # str_trauma = "NULL,
        str_kill="{name_enemy} deals a devastating strike to {name_target}! The impact causes their heart to stop. {emote_skull}",
        str_killdescriptor="punched to death",
        str_damage="{name_enemy}'s fists deal savage blows to {name_target}!",
        str_groupattack="{name_enemy} rushes down a group of shamblers with their fists!",
        fn_effect=atf_gvs_basic
    ),
    EwAttackType(  # GvS - 6
        id_type="g_brainwaves",
        str_crit="NULL",
        str_miss="**MISS!** {name_enemy}'s Binaural Brainwaves completely miss {name_target}!",
        # str_trauma_self = "NULL",
        # str_trauma = "NULL,
        str_kill="{name_enemy} hypnotizes {name_target} into walking off of the Slime's End cliffs. {emote_skull}",
        str_killdescriptor="mind broken",
        str_damage="{name_enemy}'s Binaural Brainwaves give {name_target} a massive headache!",
        str_groupattack="{name_enemy} is firing on all cylinders! Their Binaural Brainwaves impact multiple shamblers!",
        fn_effect=atf_gvs_basic
    ),
    EwAttackType(  # GvS - 7
        id_type="g_vapecloud",
        str_crit="NULL",
        str_miss="**MISS!** {name_target} completely avoids {name_enemy}'s vape cloud!",
        # str_trauma_self = "NULL",
        # str_trauma = "NULL,
        str_kill="{name_target} has inhaled too much of {name_enemy}'s toxic vape cloud! {emote_skull}",
        str_killdescriptor="vaped to death",
        str_damage="{name_enemy} completely covers {name_target} in a toxic vape cloud!",
        str_groupattack="{name_enemy} spreads its toxic vape cloud to a group of shamblers!",
        fn_effect=atf_gvs_basic
    ),
    EwAttackType(  # GvS - 8
        id_type="g_hotbox",
        str_crit="NULL",
        str_miss="**MISS!** weed",
        # str_trauma_self = "NULL",
        # str_trauma = "NULL,
        str_kill=" {emote_skull}",
        str_killdescriptor="forced to smoke too much weed",
        str_damage="weed",
        str_groupattack="weed",
        fn_effect=atf_gvs_basic
    ),
    EwAttackType(  # GvS - 9
        id_type="g_blades",
        str_crit="NULL",
        str_miss="**MISS!** {name_target} manages to avoid getting cut on {name_enemy}'s blades!",
        # str_trauma_self = "NULL",
        # str_trauma = "NULL,
        str_kill="**SHINK!!** {name_enemy}'s blades sink deep into {name_target}! {emote_skull}",
        str_killdescriptor="cut and stabbed",
        str_damage="{name_enemy} cuts {name_target} with their sharpened blades!",
        str_groupattack="{name_enemy} slices and dices a group of shamblers with their blades!",
        fn_effect=atf_gvs_basic
    ),
    EwAttackType(  # GvS - 10
        id_type="g_explosion",
        str_crit="NULL",
        str_miss="**MISS!** {name_enemy}'s explosion doesn't even come close to hitting {name_target}!",
        # str_trauma_self = "NULL",
        # str_trauma = "NULL,
        str_kill="**KABOOM!!** {name_enemy} sacrifices itself to blow {name_target} apart! {emote_skull}",
        str_killdescriptor="blown to smithereens",
        str_damage="*BOOM!* {name_enemy}'s explosion puts a dent into {name_target}!",
        str_groupattack="{name_enemy} takes down a group of shamblers with it!",
        fn_effect=atf_gvs_basic
    ),
    EwAttackType(  # GvS - 11
        id_type="s_shamboni",
        str_crit="NULL",
        str_miss="**MISS!** {name_enemy} drives right past {name_target}!",
        # str_trauma_self = "NULL",
        # str_trauma = "NULL,
        str_kill="{name_enemy}'s wheels completely flatten {name_target}! {emote_skull}",
        str_killdescriptor="run over",
        str_damage="{name_enemy}'s wheels run over {name_target}!",
        str_groupattack="{name_enemy} runs over a group of gaiaslimeoids!",
        fn_effect=atf_gvs_basic
    ),
    EwAttackType(  # GvS - 12
        id_type="s_teeth",
        str_crit="NULL",
        str_miss="**MISS!** {name_enemy}'s bite doesn't even graze {name_target}!",
        # str_trauma_self = "NULL",
        # str_trauma = "NULL,
        str_kill="**CRUNCH!** {name_enemy} devours {name_target} with their teeth! {emote_skull}",
        str_killdescriptor="bitten all over",
        str_damage="{name_enemy} bites {name_target} on their {hitzone}!",
        str_groupattack="{name_enemy}'s appetite knows no bounds! They bite into several gaiaslimeoids!",
        fn_effect=atf_gvs_basic
    ),
    EwAttackType(  # GvS - 13
        id_type="s_tusks",
        str_crit="NULL",
        str_miss="**MISS!** {name_targets}'s tusks fail to hit {name_target}, and give a loud *THUD* as they strike the ground!",
        # str_trauma_self = "NULL",
        # str_trauma = "NULL,
        str_kill="**SLAM!** {name_target} is flattened by {name_enemy}'s tusks. {emote_skull}",
        str_killdescriptor="slammed into the ground",
        str_damage="{name_enemy} bashes {name_target}'s {hitzone} with their tusks!",
        str_groupattack="{name_enemy} slams its tusks into several gaiaslimeoids!",
        fn_effect=atf_gvs_basic
    ),
    EwAttackType(  # GvS - 14
        id_type="s_fangs",
        str_crit="NULL",
        str_miss="**MISS!** {name_enemy}'s jaws snap shut! It failed to eat {name_target}!",
        # str_trauma_self = "NULL",
        # str_trauma = "NULL,
        str_kill="**GULP!** {name_enemy} swallows {name_target} whole! {emote_skull}",
        str_killdescriptor="vored to death",
        str_damage="",
        str_groupattack="NULL",
        fn_effect=atf_gvs_basic
    ),
    EwAttackType(  # GvS - 15
        id_type="s_talons",
        str_crit="NULL",
        str_miss="**MISS!** {name_enemy} couldn't get a grip on {name_target}!",
        # str_trauma_self = "NULL",
        # str_trauma = "NULL,
        str_kill="**YOINK!** {name_enemy} picks up {name_target} and carries them off into the sunset... {emote_skull}",
        str_killdescriptor="spirited away",
        str_damage="**SLASH!** {name_enemy} couldn't carry {name_target} away, but scratched them up nonetheless!",
        str_groupattack="{name_enemy} attacks a group of gaiaslimeoids with their talons!",
        fn_effect=atf_gvs_basic
    ),
    EwAttackType(  # GvS - 16
        id_type="s_molotovbreath",
        str_crit="NULL",
        str_miss="**MISS!** {name_target} managed to avoid {name_enemy}'s hellfire!",
        # str_trauma_self = "NULL",
        # str_trauma = "NULL,
        str_kill="**FWOOOOOOOSHHHHH!!** {name_enemy} burns {name_target} to a crisp! {emote_skull}",
        str_killdescriptor="burnt to ash",
        str_damage="{name_enemy} spits a ball of fire at {name_target} and burns their {hitzone}!",
        str_groupattack="{name_enemy} absolutely incinerates a group of gaiaslimeoids with their molotov breath!",
        fn_effect=atf_gvs_basic
    ),
    EwAttackType(  # GvS - 17
        id_type="s_cudgel",
        str_crit="NULL",
        str_miss="**MISS!** {name_enemy}'s cudgel misses {name_target} and goes down with a *THUD*.",
        # str_trauma_self = "NULL",
        # str_trauma = "NULL,
        str_kill="**OOF!!** {name_enemy}'s cudgel whacks {name_target} so hard, it buries them far beneath the ground. {emote_skull}",
        str_killdescriptor="flattened",
        str_damage="**BAM!** {name_enemy} strikes {name_target}'s {hitzone} with their cudgel!",
        str_groupattack="NULL",
        fn_effect=atf_gvs_basic
    ),
    EwAttackType(  # GvS - 18
        id_type="s_raiderscythe",
        str_crit="NULL",
        str_miss="**MISS!** {name_enemy}'s scythe breezes past {name_target}!",
        # str_trauma_self = "NULL",
        # str_trauma = "NULL,
        str_kill="{name_enemy} cleaves {name_target} in two. {emote_skull}",
        str_killdescriptor="cut in twain",
        str_damage="{name_enemy} slices {name_target} with its scythe!",
        str_groupattack="{name_enemy} slashes a group of gaiaslimeoids with its scythe!",
        fn_effect=atf_gvs_basic
    ),
    EwAttackType(  # GvS - 19
        id_type="s_grenadecannon",
        str_crit="NULL",
        str_miss="**MISS!** {name_enemy} couldn't land a hit on {name_target} with its grenade cannon!",
        # str_trauma_self = "NULL",
        # str_trauma = "NULL,
        str_kill="**KABAM!!** {name_enemy}'s grenade cannon lands a direct hit on {name_target}! {emote_skull}",
        str_killdescriptor="blown apart",
        str_damage="{name_target} is caught in the blast zone of {name_enemy}'s grenades!",
        str_groupattack="{name_enemy} blows up a group of gaiaslimeoids with its grenades!",
        fn_effect=atf_gvs_basic
    ),

    gvs_valid_coords_gaia = [
    ['A1', 'A2', 'A3', 'A4', 'A5', 'A6', 'A7', 'A8', 'A9'],
    ['B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B8', 'B9'],
    ['C1', 'C2', 'C3', 'C4', 'C5', 'C6', 'C7', 'C8', 'C9'],
    ['D1', 'D2', 'D3', 'D4', 'D5', 'D6', 'D7', 'D8', 'D9'],
    ['E1', 'E2', 'E3', 'E4', 'E5', 'E6', 'E7', 'E8', 'E9']
]

gvs_valid_coords_shambler = [
    ['A0', 'A0.5', 'A1', 'A1.5', 'A2', 'A2.5', 'A3', 'A3.5', 'A4', 'A4.5', 'A5', 'A5.5', 'A6', 'A6.5', 'A7', 'A7.5', 'A8', 'A8.5', 'A9', 'A9.5', 'A-S'],
    ['B0', 'B0.5', 'B1', 'B1.5', 'B2', 'B2.5', 'B3', 'B3.5', 'B4', 'B4.5', 'B5', 'B5.5', 'B6', 'B6.5', 'B7', 'B7.5', 'B8', 'B8.5', 'B9', 'B9.5', 'B-S'],
    ['C0', 'C0.5', 'C1', 'C1.5', 'C2', 'C2.5', 'C3', 'C3.5', 'C4', 'C4.5', 'C5', 'C5.5', 'C6', 'C6.5', 'C7', 'C7.5', 'C8', 'C8.5', 'C9', 'C9.5', 'C-S'],
    ['D0', 'D0.5', 'D1', 'D1.5', 'D2', 'D2.5', 'D3', 'D3.5', 'D4', 'D4.5', 'D5', 'D5.5', 'D6', 'D6.5', 'D7', 'D7.5', 'D8', 'D8.5', 'D9', 'D9.5', 'D-S'],
    ['E0', 'E0.5', 'E1', 'E1.5', 'E2', 'E2.5', 'E3', 'E3.5', 'E4', 'E4.5', 'E5', 'E5.5', 'E6', 'E6.5', 'E7', 'E7.5', 'E8', 'E8.5', 'E9', 'E9.5', 'E-S']
]

gvs_coords_end = ['A0', 'B0', 'C0', 'D0', 'E0']

gvs_coords_start = ['A-S', 'B-S', 'C-S', 'D-S', 'E-S']

gvs_enemy_emote_map = {
    enemy_type_gaia_poketubers: emote_poketubers,
    enemy_type_gaia_pulpgourds: emote_pulpgourds,
    enemy_type_gaia_sourpotatoes: emote_sourpotatoes,
    enemy_type_gaia_bloodcabbages: emote_bloodcabbages,
    enemy_type_gaia_joybeans: emote_joybeans,
    enemy_type_gaia_purplekilliflower: emote_killiflower,
    enemy_type_gaia_razornuts: emote_razornuts,
    enemy_type_gaia_pawpaw: emote_pawpaw,
    enemy_type_gaia_sludgeberries: emote_sludgeberries,
    enemy_type_gaia_suganmanuts: emote_suganmanuts,
    enemy_type_gaia_pinkrowddishes: emote_pinkrowddishes,
    enemy_type_gaia_dankwheat: emote_dankwheat,
    enemy_type_gaia_brightshade: emote_brightshade,
    enemy_type_gaia_blacklimes: emote_blacklimes,
    enemy_type_gaia_phosphorpoppies: emote_phosphorpoppies,
    enemy_type_gaia_direapples: emote_direapples,
    enemy_type_gaia_rustealeaves: emote_rustealeaves,
    enemy_type_gaia_metallicaps: emote_metallicaps,
    enemy_type_gaia_steelbeans: emote_steelbeans,
    enemy_type_gaia_aushucks: emote_aushucks,
    'frozen': emote_frozentile,
}

gvs_enemy_emote_map_debug = {
    enemy_type_gaia_poketubers: ':potato:',
    enemy_type_gaia_pulpgourds: ':lemon:',
    enemy_type_gaia_sourpotatoes: ':sweet_potato:',
    enemy_type_gaia_bloodcabbages: ':tomato:',
    enemy_type_gaia_joybeans: ':rainbow:',
    enemy_type_gaia_purplekilliflower: ':broccoli:',
    enemy_type_gaia_razornuts: ':chestnut:',
    enemy_type_gaia_pawpaw: ':pear:',
    enemy_type_gaia_sludgeberries: ':grapes:',
    enemy_type_gaia_suganmanuts: ':peanuts:',
    enemy_type_gaia_pinkrowddishes: ':strawberry:',
    enemy_type_gaia_dankwheat: ':herb:',
    enemy_type_gaia_brightshade: ':hibiscus:',
    enemy_type_gaia_blacklimes: ':garlic:',
    enemy_type_gaia_phosphorpoppies: ':blossom:',
    enemy_type_gaia_direapples: ':apple:',
    enemy_type_gaia_rustealeaves: ':fallen_leaf:',
    enemy_type_gaia_metallicaps: ':mushroom:',
    enemy_type_gaia_steelbeans: ':shield:',
    enemy_type_gaia_aushucks: ':corn:',
    'frozen': ':snowflake:',
}

 if enemytype in ewcfg.gvs_enemies_gaiaslimeoids:
                response = "**A {} has been planted in {}!!**".format(enemy.display_name, enemy.gvs_coord)
            elif enemytype in ewcfg.gvs_enemies_shamblers:
                response = "**A {} creeps forward!!** It spawned in {}!".format(enemy.display_name, enemy.gvs_coord)


 # Old capping CMD
"""async def annex(cmd):
	user_data = EwUser(member = cmd.message.author)
	if user_data.life_state == ewcfg.life_state_shambler:
		response = "You lack the higher brain functions required to {}.".format(cmd.tokens[0])
		return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

	response = ""
	resp_cont = ewutils.EwResponseContainer(id_server = cmd.guild.id)
	time_now = int(time.time())

	poi = poi_static.id_to_poi.get(user_data.poi)

	if user_data.life_state == ewcfg.life_state_corpse:
		response = "You ineffectively try shaking your can of spraypaint to whip up some sick graffiti. Alas, youre all outta slime. " \
                   "They should really make these things compatible with ectoplasm."
		return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

	if not (len(user_data.faction) > 0 and user_data.life_state == ewcfg.life_state_enlisted):
		response = "Juveniles are too chickenshit to make graffiti and risk getting busted by the cops. Fuckin losers."
		return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

	if user_data.poi in [ewcfg.poi_id_rowdyroughhouse, ewcfg.poi_id_copkilltown]:
		response = "Theres no point, the rest of your gang has already covered this place in spraypaint. Focus on exporting your graffiti instead."
		return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

	if user_data.poi == ewcfg.poi_id_juviesrow:
		response = "Nah, the Rowdys and Killers have both agreed this is neutral ground. You dont want to start a diplomatic crisis, " \
                   "just stick to spraying down sick graffiti and splattering your rival gang across the pavement in the other districts."
		return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

	if not user_data.poi in poi_static.capturable_districts:
		response = "This zone cannot be captured."
		return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

	district_data = EwDistrict(id_server = user_data.id_server, district = user_data.poi)


	if district_data.is_degraded():
		response = "{} has been degraded by shamblers. You can't {} here anymore.".format(poi.str_name, cmd.tokens[0])
		return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))
	if district_data.time_unlock > 0:
		response = "You cant spray graffiti here yet, its too soon after your rival gang extended their own cultural dominance over it. Try again in {}.".format(ewutils.formatNiceTime(seconds = district_data.time_unlock, round_to_minutes = True))
		return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

	if district_data.all_neighbors_friendly():
		response = "What the hell are you doing, dude? You cant put down any graffiti here, its been completely overrun by your rival gang. " \
                   "You can only spray districts that have at least one unfriendly neighbor, duh!"
		return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

	users_in_district = district_data.get_players_in_district(
		life_states = [ewcfg.life_state_enlisted],
		ignore_offline = True,
		pvp_only = True
	)

	allies_in_district = district_data.get_players_in_district(
		factions = [user_data.faction],
		life_states = [ewcfg.life_state_enlisted],
		ignore_offline = True,
		pvp_only = True
	)

	if len(users_in_district) > len(allies_in_district):
		response = "Holy shit, deal with your rival gangsters first! You cant spray graffiti while theyre on the prowl!"
		return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

	mutations = user_data.get_mutations()

	slimes_spent = ewutils.getIntToken(tokens = cmd.tokens, allow_all = True)
	capture_discount = 1

	if ewcfg.mutation_id_lonewolf in mutations:
		if user_data.time_expirpvp > time_now:
			if len(users_in_district) == 1:
				capture_discount *= 0.8
		else:
			if len(users_in_district) == 0:
				capture_discount *= 0.8

	if ewcfg.mutation_id_patriot in mutations:
		capture_discount *= 0.8

	if slimes_spent == None:
		response = "How much slime do you want to spend on spraying graffiti in this district?"
		return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

	if slimes_spent < 0:
		slimes_spent = user_data.slimes

	if slimes_spent > user_data.slimes:
		response = "You don't have that much slime, retard."
		return await fe_utils.send_message(cmd.client, cmd.message.channel, fe_utils.formatMessage(cmd.message.author, response))

	num_lock = len(allies_in_district)
	if user_data.time_expirpvp < time_now:
		num_lock += 1

	if (district_data.controlling_faction not in ["", user_data.faction]) or (district_data.capturing_faction not in ["", user_data.faction]):
		slimes_decap = min(district_data.capture_points, int(slimes_spent / capture_discount))
		decap_resp = district_data.change_capture_points(
			progress = -slimes_decap,
			actor = user_data.faction,
			num_lock = num_lock
		)
		resp_cont.add_response_container(decap_resp)

		user_data.change_slimes(n = -slimes_decap * capture_discount, source = ewcfg.source_spending)
		slimes_spent -= slimes_decap * capture_discount

	slimes_cap = min(district_data.max_capture_points - district_data.capture_points, int(slimes_spent / capture_discount))
	cap_resp = district_data.change_capture_points(
		progress = slimes_cap,
		actor = user_data.faction,
		num_lock = num_lock
	)
	resp_cont.add_response_container(cap_resp)

	user_data.change_slimes(n = -slimes_cap * capture_discount, source = ewcfg.source_spending)

	# Flag the user for PvP
	# user_data.time_expirpvp = ewutils.calculatePvpTimer(user_data.time_expirpvp, ewcfg.time_pvp_annex, True)

	user_data.persist()
	district_data.persist()
	await ewrolemgr.updateRoles(client = cmd.client, member = cmd.message.author)

	return await resp_cont.post()
"""
        # topdonated = make_userdata_board(server=server.id, category=ewcfg.col_splattered_slimes, title=ewcfg.leaderboard_donated)
        # resp_cont.add_channel_response(leaderboard_channel, topdonated)

           if enemy_data.enemytype in ewcfg.raid_bosses:
        if enemy_data.enemytype in ewcfg.gvs_enemies:
            if enemy_data.time_lastenter <= time_now - 600:
                # Raid boss can move
                return True
            elif enemy_data.time_lastenter > time_now - 600:
                # Raid boss can't move yet
                return False